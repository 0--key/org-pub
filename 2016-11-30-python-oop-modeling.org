#+BEGIN_HTML
---
layout: post
title: Write Python programs
tagline: " in OOP manner"
permalink: /python/oop-modeling.html
categories: [literate programming, Python, object-oriented-programming, emacs]
tags: [coding, algorithms, oop]
---
#+END_HTML
#+STARTUP: showall
#+OPTIONS: tags:nil num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t
#+TOC: headlines 2

* It is a contemporary and effective craft-writing
  But, for a little while as much of stuff around us. As a corner case of object-oriented programming
  it would be nice to define where it is evil to use it.

** It is silly
   - To take challenge and write in OOP manner for 10 or less objects.
   - In addition you restricted to consider about the number of iteration your code snippet.
     Sometimes it might be conscious and sober to try just /prototype/ your function. Even
     it is obvious - the raw model should disclose many of hidden niceties about how things
     work separately.


** The good practice
   - Long-run projects with active code evolution. If it is a true development it is obligation
     to following through scalability path only. And OOP itself allows you to forget about limits
     in computation. There are millions items inside your Python are the real number for large
     application.
   - Strict and narrow object's relations is a huge necessary component. Branches, trees and even
     leaves are typical reproducible structures.


* Samples

** Inheritance from the parent class general sample:
   #+BEGIN_SRC python :results output
     class InitialClass(object):

         def __init__(self):
             self.attr1 = 'one'
             self.attr2 = 'two'

     class InheritedClass(InitialClass):

         def __init__(self):
             self.attr3 = 'three'
             # strict inheritance
             # InitialClass.__init__(self)
             # relative inheritance
             super(InheritedClass, self).__init__()


         @staticmethod
         def somemethod():
             """It's just for illustration"""
             print('the method')


     a = InheritedClass()

     for each in a.__dict__:
         print(each)
     a.somemethod()
   #+END_SRC

   #+RESULTS:
   : attr2
   : attr1
   : attr3
   : the method

   As you might noticed several attributes ~a~ inherited out from two
   classes. And in general case it allows you to extend your initial
   class by addition some new attributes or even functions.
** Grocery store
   
*** Persons

**** Primitive sample with strict inheritance
     #+BEGIN_SRC python :session oop :results output
       class Person(object):
           def __init__(self, name):
               self.name = name

       class Customer(Person):
           def __init__(self, name, deposit):
               super(Customer, self).__init__(name)
               self.deposit = deposit


       a = Customer(name='John', deposit=123)
       print '\n', a.deposit, a.name
     #+END_SRC

     #+RESULTS:
     : 
     : ... ... ... >>> ... ... ... ... >>> >>> >>> 
     : 123 John

**** Complicated sample with fluid inheritance
     #+BEGIN_SRC python :session oop :results output
       class Person(object):
           def __init__(self, name):
               self.name = name

       class Customer(Person):
           def __init__(self, name, deposit):
               super(Customer, self).__init__(name)
               self.deposit = deposit


       a = Customer(name='John', deposit=123)
       print '\n', a.deposit, a.name
     #+END_SRC

     #+RESULTS:
     : 
     : >>> >>> ... ... ... >>> ... ... ... ... >>> >>> >>> 
     : 123 John


*** Meal

*** Basket

*** Payments

** Pine forest

*** Trees

*** Area

*** Population

* Conclusion
   
