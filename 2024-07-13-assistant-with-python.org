#+BEGIN_EXPORT html
---
layout: page
title: OpenAI Assistance
tagline: " with Python code interpreter"
permalink: /openai/python-code-interpreter.html
categories: [OpenAI, Python, Assistant]
tags: [code interpreter]
---
#+END_EXPORT
#+STARTUP: showall indent
#+OPTIONS: tags:nil num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t
#+PROPERTY: header-args :exports both
#+PROPERTY: header-args+ :results output pp
#+PROPERTY: header-args+ :eval no-export
#+PROPERTY: vizier-thread-id thread_bEfocrvYp57YATvOo3EmvkDV
#+PROPERTY: vizier-assistant-id asst_Qy77LlTvrNX9xGWl5jxGnK46
#+TOC: headlines 2


* Preamble

The purpose of this article is to test the dexterity of the OpenAI
Assistant in solving programming tasks based on their descriptions in
English and the associated test suite requirements.

* Prerequisites

=OpenAI Assistant= with ~code_interpreter~ as the tool.

* Question #1 medium

Write a function `last_digit` that takes in two numbers a and b and
returns the last decimal digit of a^b.  Note that a and b may be very
large!

For example, the last decimal digit of 9^{7} is 9, since 9^{7}
= 4782969. The last decimal digit of (2^{200})^{(2^{300})}, which has
over 10^{92} decimal digits, is 6.

The inputs to your function will always be non-negative integers.

`last_digit` ought to pass all this assertions:
```
assert(last_digit(4, 1) == 4)
assert(last_digit(4, 2) == 6)
assert(last_digit(9, 7) == 9)
assert(last_digit(10, 10 ** 10) == 0)
assert(last_digit(2 ** 200, 2 ** 300) == 6)
```
#+begin_src markdown
  ```python
  def last_digit(a, b):
      if b == 0:
          return 1
      return pow(a, b, 10)

  # Assertions to validate the function
  assert(last_digit(4, 1) == 4)
  assert(last_digit(4, 2) == 6)
  assert(last_digit(9, 7) == 9)
  assert(last_digit(10, 10 ** 10) == 0)
  assert(last_digit(2 ** 200, 2 ** 300) == 6)
  ```
#+end_src

** Validation
#+begin_src python
# Just a test
  print(pow(2**200, 2**300, 10))
#+end_src

#+RESULTS:
: 6


* Question #2 primitive

Write a function `get_vowels_count` that returns the number (count) of
vowels in the given string. We will consider a, e, i, o, and u as
vowels.

`get_vowels_count` ought to pass this assertion:
```
assert (get_vowels_count('John the dully boy write this book') == 9)
```

#+begin_src markdown
  ```python
  def get_vowels_count(s):
      return sum(1 for char in s.lower() if char in 'aeiou')

  # Assertion to validate the function
  assert (get_vowels_count('John the dully boy write this book') == 9)
  ```
#+end_src

* Question #3 with raw description

Consider a sequence u where u is defined as follows:

The number u(0) = 1 is the first one in u.
For each x in u, then y = 2 * x + 1 and z = 3 * x + 1 must be in u too.
There are no other numbers in u.
Ex: u = [1, 3, 4, 7, 9, 10, 13, 15, 19, 21, 22, 27, ...]

1 gives 3 and 4, then 3 gives 7 and 10, 4 gives 9 and 13, then 7 gives 15
and 22 and so on...

Task:

Given parameter n the function dbl_linear (or dblLinear...) returns the element
u(n) of the ordered (with <) sequence u.

Example:

dbl_linear(10) should return 22

Note:

Focus attention on efficiency
#+begin_src markdown
  ```python
  from heapq import heappop, heappush

  def dbl_linear(n):
      u = [1]
      seen = {1}
    
      for _ in range(n):
          x = heappop(u)
          for y in [2 * x + 1, 3 * x + 1]:
              if y not in seen:
                  seen.add(y)
                  heappush(u, y)
                
      return heappop(u)

  # Example assertion to validate the function
  assert(dbl_linear(10) == 22)
  ```
#+end_src

* #4 another raw description

For a given chemical formula represented by a string, count the number
of atoms of each element contained in the molecule and return an object.

For example:

water = 'H2O'
parse_molecule(water)                 # return {H: 2, O: 1}

magnesium_hydroxide = 'Mg(OH)2'
parse_molecule(magnesium_hydroxide)   # return {Mg: 1, O: 2, H: 2}

var fremy_salt = 'K4[ON(SO3)2]2'
parse_molecule(fremySalt)             # return {K: 4, O: 14, N: 2, S: 4}

As you can see, some formulas have brackets in them. The index outside the
brackets tells you that you have to multiply count of each atom inside the
bracket on this index. For example, in Fe(NO3)2 you have one iron atom,
two nitrogen atoms and six oxygen atoms.

Note that brackets may be round, square or curly and can also be nested.
Index after the braces is optional.

#+begin_src markdown
  ```python
  import re
  from collections import defaultdict

  def parse_molecule(formula):
      def multiply_dict(d, n):
          return {k: v * n for k, v in d.items()}
    
      def parse_section(section):
          atoms = defaultdict(int)
          i = 0
          while i < len(section):
              if section[i].isalpha():
                  j = i + 1
                  while j < len(section) and section[j].islower():
                      j += 1
                  element = section[i:j]
                  k = j
                  while k < len(section) and section[k].isdigit():
                      k += 1
                  count = int(section[j:k] or 1)
                  atoms[element] += count
                  i = k
              elif section[i] in '([{':
                  stack = []
                  brackets = {'(': ')', '[': ']', '{': '}'}
                  close_bracket = brackets[section[i]]
                  for j in range(i, len(section)):
                      if section[j] == section[i]:
                          stack.append(section[i])
                      elif section[j] == close_bracket:
                          stack.pop()
                      if not stack:
                          break
                  content = parse_section(section[i + 1: j])
                  k = j + 1
                  while k < len(section) and section[k].isdigit():
                      k += 1
                  multiplier = int(section[j + 1: k] or 1)
                  content = multiply_dict(content, multiplier)
                  for key, val in content.items():
                      atoms[key] += val
                  i = k
          return atoms
        
      return parse_section(formula)

  # Example assertions to validate the function
  assert parse_molecule('H2O') == {'H': 2, 'O': 1}
  assert parse_molecule('Mg(OH)2') == {'Mg': 1, 'O': 2, 'H': 2}
  assert parse_molecule('K4[ON(SO3)2]2') == {'K': 4, 'O': 14, 'N': 2, 'S': 4}
  ```
#+end_src

* #5

You have to create a function that takes a positive integer number and returns the
next bigger number formed by the same digits:

next_bigger(12)==21
next_bigger(513)==531
next_bigger(2017)==2071

If no bigger number can be composed using those digits, return -1:

next_bigger(9)==-1
next_bigger(111)==-1
next_bigger(531)==-1

#+begin_src markdown
  ```python
  def next_bigger(n):
      digits = list(str(n))
    
      # Find the rightmost digit that is smaller than the digit next to it
      for i in range(len(digits) - 2, -1, -1):
          if digits[i] < digits[i + 1]:
              break
      else:
          return -1
    
      # Find the smallest digit on the right that is larger than digits[i]
      for j in range(len(digits) - 1, i, -1):
          if digits[j] > digits[i]:
              break
    
      # Swap the two digits
      digits[i], digits[j] = digits[j], digits[i]
    
      # Reverse the digits to the right of i
      digits = digits[:i + 1] + sorted(digits[i + 1:])
    
      return int(''.join(digits))

  # Example assertions to validate the function
  assert next_bigger(12) == 21
  assert next_bigger(513) == 531
  assert next_bigger(2017) == 2071
  assert next_bigger(9) == -1
  assert next_bigger(111) == -1
  assert next_bigger(531) == -1
  ```
#+end_src

* # Optimization

Optimize the function `parse_molecule`:

```
  import re
  from collections import defaultdict

  def parse_molecule(formula):
      def multiply_dict(d, n):
          return {k: v * n for k, v in d.items()}
    
      def parse_section(section):
          atoms = defaultdict(int)
          i = 0
          while i < len(section):
              if section[i].isalpha():
                  j = i + 1
                  while j < len(section) and section[j].islower():
                      j += 1
                  element = section[i:j]
                  k = j
                  while k < len(section) and section[k].isdigit():
                      k += 1
                  count = int(section[j:k] or 1)
                  atoms[element] += count
                  i = k
              elif section[i] in '([{':
                  stack = []
                  brackets = {'(': ')', '[': ']', '{': '}'}
                  close_bracket = brackets[section[i]]
                  for j in range(i, len(section)):
                      if section[j] == section[i]:
                          stack.append(section[i])
                      elif section[j] == close_bracket:
                          stack.pop()
                      if not stack:
                          break
                  content = parse_section(section[i + 1: j])
                  k = j + 1
                  while k < len(section) and section[k].isdigit():
                      k += 1
                  multiplier = int(section[j + 1: k] or 1)
                  content = multiply_dict(content, multiplier)
                  for key, val in content.items():
                      atoms[key] += val
                  i = k
          return atoms
        
      return parse_section(formula)
```

it ought to fit into this set of assertions:
```
  assert parse_molecule('H2O') == {'H': 2, 'O': 1}
  assert parse_molecule('Mg(OH)2') == {'Mg': 1, 'O': 2, 'H': 2}
  assert parse_molecule('K4[ON(SO3)2]2') == {'K': 4, 'O': 14, 'N': 2, 'S': 4}
```
#+begin_src markdown
  ```python
  import re
  from collections import defaultdict

  def parse_molecule(formula):
      def multiply_dict(d, n):
          for k in d:
              d[k] *= n
          return d
    
      def parse_section(section):
          atoms = defaultdict(int)
          pattern = re.compile(r'([A-Z][a-z]*)(\d*)|([\(\[\{])|([\)\]\}])(\d*)')
          stack = [defaultdict(int)]
          multipliers = [1]
        
          for match in pattern.finditer(section):
              element, num, open_brac, close_brac, multiplier = match.groups()
              if element:
                  count = int(num) if num else 1
                  stack[-1][element] += count * multipliers[-1]
              elif open_brac:
                  stack.append(defaultdict(int))
                  multipliers.append(multipliers[-1])
              elif close_brac:
                  if multiplier:
                      count = int(multiplier)
                      stack[-1] = multiply_dict(stack.pop(), count)
                  for k, v in stack.pop().items():
                      stack[-1][k] += v * multipliers[-1]
          return stack.pop()
    
      return parse_section(formula)

  # Example assertions to validate the function
  assert parse_molecule('H2O') == {'H': 2, 'O': 1}
  assert parse_molecule('Mg(OH)2') == {'Mg': 1, 'O': 2, 'H': 2}
  assert parse_molecule('K4[ON(SO3)2]2') == {'K': 4, 'O': 14, 'N': 2, 'S': 4}
  ```
#+end_src

* #7 Thread-specific question

Write the function `parse_molecule` not using standard library modules
`re` and `collections`.
#+begin_src markdown
  ```python
  def parse_molecule(formula):
      def multiply_dict(d, n):
          for k in d:
              d[k] *= n
          return d
    
      def parse_section(section):
          atoms = {}
          stack = []
          multipliers = [1]
          n = len(section)
          i = 0
        
          while i < n:
              if section[i].isalpha():
                  start = i
                  i += 1
                  while i < n and section[i].islower():
                      i += 1
                  element = section[start:i]
                  start = i
                  while i < n and section[i].isdigit():
                      i += 1
                  count = int(section[start:i]) if start != i else 1
                  atoms[element] = atoms.get(element, 0) + count * multipliers[-1]
              elif section[i] in '([{':
                  stack.append(atoms)
                  atoms = {}
                  multipliers.append(multipliers[-1])
                  i += 1
              elif section[i] in ')]}':
                  i += 1
                  start = i
                  while i < n and section[i].isdigit():
                      i += 1
                  multiplier = int(section[start:i]) if start != i else 1
                  atoms = multiply_dict(atoms, multiplier)
                  if stack:
                      prev_atoms = stack.pop()
                      for k, v in atoms.items():
                          prev_atoms[k] = prev_atoms.get(k, 0) + v
                      atoms = prev_atoms
                  multipliers.pop()
              else:
                  i += 1

          return atoms
    
      return parse_section(formula)

  # Example assertions to validate the function
  assert parse_molecule('H2O') == {'H': 2, 'O': 1}
  assert parse_molecule('Mg(OH)2') == {'Mg': 1, 'O': 2, 'H': 2}
  assert parse_molecule('K4[ON(SO3)2]2') == {'K': 4, 'O': 14, 'N': 2, 'S': 4}
  ```
#+end_src

