#+BEGIN_EXPORT html
---
layout: post
title: Algorithms
tagline: " brief overview"
permalink: /fundamentals/algorithms-overview.html
categories: [Algorithms]
tags: []
---
#+END_EXPORT

#+STARTUP: showall indent
#+AUTHOR:    Anton S. Kosinov
#+TITLE:     A brief introduction into
#+SUBTITLE:  the computational algorithms
#+EMAIL:     a.s.kosinov@gmail.com
#+LANGUAGE: en
#+OPTIONS: tags:nil num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t
#+TOC: headlines 2

* Overview

The main algorithms in computer science cover a wide range of
problem-solving techniques. Here are some key categories of algorithms
commonly used in computer science:


* Optimization Algorithms

** Searching

Searching algorithms in computer science are designed to locate
specific elements or items within a collection of data. These
algorithms efficiently navigate through data structures to find the
desired information. Some key points about searching algorithms:

- They are fundamental in various applications such as databases, web
  search engines, and more[1].
- Searching algorithms can be classified based on their mechanism of
  searching into linear, binary, and hashing algorithms[2].
- Linear search algorithms check every record in a linear fashion
  until the target is found. They have a time complexity of
  O(n)[1][3].
- Binary search algorithms repeatedly target the center of a sorted
  data structure and divide the search space in half. They have a time
  complexity of O(log n), making them very efficient[1][3].
- Hashing directly maps keys to records based on a hash function[2].
- Searching algorithms are often evaluated by their computational
  complexity, which represents the maximum theoretical run time[2].

Specific applications of searching algorithms include combinatorial
optimization problems, constraint satisfaction problems, game theory,
cryptography, database querying, and finding maximum/minimum
values[2].

Citations:
[1] https://www.geeksforgeeks.org/searching-algorithms/
[2] https://en.wikipedia.org/wiki/Search_algorithm
[3] https://pmt.physicsandmathstutor.com/download/Computer-Science/A-level/Notes/OCR/2.3-Algorithms-AS/Advanced/2.3.4.%20Searching%20Algorithms.pdf
[4] https://adacomputerscience.org/topics/searching
[5] https://www.csunplugged.org/en/topics/searching-algorithms/
#+begin_quote

#+end_quote


** Sorting

Sorting algorithms in computer science are essential procedures used
to organize data efficiently in a specific order, typically ascending
or descending. These algorithms play a crucial role in various
applications within computer science, such as database sort-merge join
algorithms and search algorithms like binary search. Sorting
algorithms are integral to optimizing the efficiency of other
algorithms and data handling, facilitating faster and more effective
data management. They are vital for enhancing data access speed,
improving resource management, and supporting more efficient and
insightful data analysis outcomes.

Some common sorting algorithms include Bubble Sort, Selection Sort,
Insertion Sort, Merge Sort, Quick Sort, Heap Sort, Counting Sort,
Radix Sort, and Bucket Sort. Each of these algorithms has unique
advantages, disadvantages, and performance complexities. Sorting
algorithms can be categorized based on parameters like the number of
swaps or inversions, the number of comparisons, recursion or
non-recursion, stability, and extra space requirement. The best
possible time complexity for any comparison-based sorting algorithm is
$$O(n \log n)$$, with algorithms like Heapsort and Merge Sort being
asymptotically optimal comparison sorts[3][5].

Citations:
[1] https://www.studysmarter.co.uk/explanations/computer-science/algorithms-in-computer-science/sorting-algorithms/
[2] https://brilliant.org/wiki/sorting-algorithms/
[3] https://www.freecodecamp.org/news/sorting-algorithms-explained/
[4] https://pmt.physicsandmathstutor.com/download/Computer-Science/A-level/Notes/OCR/2.3-Algorithms/Intermediate/2.3.3.%20Sorting%20Algorithms.pdf
[5] https://www.geeksforgeeks.org/sorting-algorithms/

The main sorting algorithms in computer science are:

1. Bubble Sort: Repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The largest element "bubbles" to the end of the list[1][3].

2. Selection Sort: Finds the minimum element from the unsorted part of the array and swaps it with the first element of the unsorted part[1][3]. 

3. Insertion Sort: Builds the final sorted array one element at a time. It iterates through the array, removing one element per iteration, and inserting it into its correct position in the sorted portion[1][3].

4. Merge Sort: Divides the unsorted list into n sublists, each containing one element, then repeatedly merges these sublists to produce sorted sublists until there is only one sublist remaining[1][2].

5. Quick Sort: Picks a 'pivot' element from the array and partitions the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. It recursively applies this process to the sub-arrays[1][2].

6. Heap Sort: Builds a binary heap data structure from the array, and then uses the heap to sort the array[1][2].

7. Radix Sort: Sorts the elements based on the digits. It starts with the least significant digit and works its way up to the most significant digit[2][4].

These algorithms vary in their efficiency, stability, and memory
usage. The choice depends on the specific requirements of the problem
at hand[1][2][4].

Citations:
[1] https://www.studysmarter.co.uk/explanations/computer-science/algorithms-in-computer-science/sorting-algorithms/
[2] https://www.freecodecamp.org/news/sorting-algorithms-explained/
[3] https://pmt.physicsandmathstutor.com/download/Computer-Science/A-level/Notes/OCR/2.3-Algorithms/Intermediate/2.3.3.%20Sorting%20Algorithms.pdf
[4] https://www.geeksforgeeks.org/sorting-algorithms/
[5] https://www.bbc.co.uk/bitesize/guides/zjdkw6f/revision/4


** Hybrid Algorithms

#+begin_quote
Hybrid algorithms in computer science refer to algorithms that combine
two or more other algorithms that solve the same problem, either by
choosing one based on certain data characteristics or by switching
between them during the algorithm's execution. These hybrid algorithms
aim to leverage the strengths of each component algorithm to create a
more effective overall solution.
#+end_quote
   - Graph Algorithms
     - Coloring Algorithm
     - Hopcroft–Karp Algorithm
     - Hungarian Algorithm
     - Prüfer Coding
     - Tarjan's Off-line Lowest Common Ancestors Algorithm
     - Topological Sort



*  Graph Drawing:
   - Force-based Algorithms
   - Spectral Layout


* Network Theory:
   - Girvan–Newman Algorithm
   - Hyperlink-Induced Topic Search (HITS)
   - PageRank
   - TrustRank
   - Flow Networks
     - Dinic's Algorithm
     - Edmonds–Karp Algorithm
     - Ford–Fulkerson Algorithm
     - Karger's Algorithm
     - Push–relabel Algorithm

4. Routing for Graphs:
   - Edmonds' Algorithm
   - Euclidean Minimum Spanning Tree
   - Longest Path Problem
   - Minimum Spanning Tree
   - Shortest Path Problem
     - Bellman–Ford Algorithm
     - Dijkstra's Algorithm
     - Floyd–Warshall Algorithm
     - Johnson's Algorithm
   - Transitive Closure Problem
   - Traveling Salesman Problem
   - Warnsdorff's Rule

5. Graph Search:
   - A*
   - B*
   - Backtracking
   - Beam Search
   - Beam Stack Search
   - Best-first Search
   - Bidirectional Search
   - Breadth-first Search
   - Brute-force Search
   - D*
   - Depth-first Search
   - General Problem Solver
   - Iterative Deepening Depth-first Search (IDDFS)
   - Jump Point Search
   - Lexicographic Breadth-first Search (Lex-BFS)
   - Uniform-cost Search
   - SSS*

6. Subgraphs:
   - Cliques
   - Bron–Kerbosch Algorithm
   - MaxCliqueDyn Maximum Clique Algorithm
   - Strongly Connected Components
   - Subgraph Isomorphism Problem

These algorithms play a crucial role in various applications within
computer science, from network analysis to pathfinding and
optimization. Each algorithm serves a specific purpose in solving
computational problems efficiently and effectively[1][4].
