#+BEGIN_HTML
---
layout: post
title: Python
tagline: " built-in functions in TDD"
permalink: /python/stdlib/python-built-in-functions.html
categories: [python, stdlib, TDD, literate programming]
tags: [built-in functions, unittest]
---
#+END_HTML
#+OPTIONS: tags:nil num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t

#+TOC: headlines 2

* Preamble
  In most cases the best approach to study how something works is to
  test its behavior in various circumstances. In a helicopter view it
  is a dissection or a scrutiny.

  The same approach for studying programming language has a plethora
  benefits and the most significant is that it take you chance to play
  with code. Of cause studying by playing is a most natural way of
  learning.

* Documentation
  At [[https://docs.python.org/3/library/functions.html][official web-site]].

  The Python interpreter has a number of functions and types built into
  it that are always available. They are listed here in alphabetical
  order.
  #+BEGIN_QUOTE
                           *Built-in Functions*
| abs()         | dict()      | help()       | min()      | setattr()      |
| all()         | dir()       | hex()        | next()     | slice()        |
| any()         | divmod()    | id()         | object()   | sorted()       |
| ascii()       | enumerate() | input()      | oct()      | staticmethod() |
| bin()         | eval()      | int()        | open()     | str()          |
| bool()        | exec()      | isinstance() | ord()      | sum()          |
| bytearray()   | filter()    | issubclass() | pow()      | super()        |
| bytes()       | float()     | iter()       | print()    | tuple()        |
| callable()    | format()    | len()        | property() | type()         |
| chr()         | frozenset() | list()       | range()    | vars()         |
| classmethod() | getattr()   | locals()     | repr()     | zip()          |
| compile()     | globals()   | map()        | reversed() | __import__()   |
| complex()     | hasattr()   | max()        | round()    |                |
| delattr()     | hash()      | memoryview() | set()      |                |
|               |             |              |            |                |
  #+END_QUOTE


* Methodology
  Seems like the best approach is to test each function and ensure how they work.

** Template
   Lets create a mold for pouring by the test suits:


   #+BEGIN_SRC python :noweb yes :tangle tests/test_built-in_functions.py
   """Discover how they work by a coherent testing"""
   <<import-header>>


   <<abs-test-suite>>
   <<all-test-suite>>
   <<any-test-suite>>
   #+END_SRC   


   #+BEGIN_QUOTE
   *Tip* Use =C-c C-v t= to generate /(tangle)/ the test file
   #+END_QUOTE

** Necessary imports
   It's clear what you expected to test by means the =unittest= module:


   #+NAME: import-header
   #+BEGIN_SRC python
   import unittest
   #+END_SRC

** Test suits
   Each test case class as a separate source code block with a
   particular name for substitution into template.

*** abs()

    #+NAME: abs-test-suite
    #+BEGIN_SRC python
      class TestAbs(unittest.TestCase):

          def test_positive(self):
              self.assertTrue(abs(4) == 4)

          def test_negative(self):
              self.assertFalse(abs(-4) == -4)


    #+END_SRC

*** all()
    
   #+NAME: all-test-suite
   #+BEGIN_SRC python
     class TestAll(unittest.TestCase):

         def test_one_value_is_zero(self):
             self.assertFalse(all([0, 1]))

         def test_all_values_are_positive_numbers(self):
             self.assertTrue(all([1, 2, 3]))

         def test_single_element_is_false(self):
             self.assertFalse(all([False, 3]))

         def test_single_element_is_None(self):
             self.assertFalse(all([None, 3]))

         def test_all_values_are_negative(self):
             self.assertTrue(all([-1, -2]))

         def test_all_values_are_strings(self):
             self.assertTrue(all(["String", "value"]))

         def test_one_value_is_empty_string(self):
             self.assertFalse(all(["", "Empty"]))
   #+END_SRC
    

** Test runner
   Accustomed unittest as Python module:


   #+BEGIN_SRC sh :results output :exports both
     python -m unittest -v tests/test_built-in_functions.py

   #+END_SRC

   #+RESULTS:
   #+begin_example
   test_negative (tests.test_built-in_functions.TestAbs) ... ok
   test_positive (tests.test_built-in_functions.TestAbs) ... ok
   test_all_values_are_negative (tests.test_built-in_functions.TestAll) ... ok
   test_all_values_are_positive_numbers (tests.test_built-in_functions.TestAll) ... ok
   test_all_values_are_strings (tests.test_built-in_functions.TestAll) ... ok
   test_one_value_is_empty_string (tests.test_built-in_functions.TestAll) ... ok
   test_one_value_is_zero (tests.test_built-in_functions.TestAll) ... ok
   test_single_element_is_None (tests.test_built-in_functions.TestAll) ... ok
   test_single_element_is_false (tests.test_built-in_functions.TestAll) ... ok

   ----------------------------------------------------------------------
   Ran 9 tests in 0.001s

   OK
#+end_example


* Conclusion
  Now it is totally clear how to compose tests for Python standard
  library testing in a literate programming style.
