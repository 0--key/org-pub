#+BEGIN_HTML
---
layout: post
title: Python
tagline: " built-in functions in TDD"
permalink: /python/stdlib/python-built-in-functions.html
categories: [python, stdlib, TDD, literate programming]
tags: [built-in functions, unittest]
---
#+END_HTML
#+OPTIONS: tags:nil num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t

#+TOC: headlines 2

* Preamble
  In most cases the best approach to study how something works is to
  test its behavior in various circumstances. In a helicopter view it
  is a dissection or a scrutiny.

  The same approach for studying programming language has a plethora
  benefits and the most significant is that it take you chance to play
  with code. Of cause studying by playing is a most natural way of
  learning.

* Documentation
  At [[https://docs.python.org/3/library/functions.html][official web-site]].

  The Python interpreter has a number of functions and types built into
  it that are always available. They are listed here in alphabetical
  order.

** Built-ins
   #+BEGIN_QUOTE
                            *Built-in Functions*
 | abs()         | dict()      | help()       | min()      | setattr()      |
 | all()         | dir()       | hex()        | next()     | slice()        |
 | any()         | divmod()    | id()         | object()   | sorted()       |
 | ascii()       | enumerate() | input()      | oct()      | staticmethod() |
 | bin()         | eval()      | int()        | open()     | str()          |
 | bool()        | exec()      | isinstance() | ord()      | sum()          |
 | bytearray()   | filter()    | issubclass() | pow()      | super()        |
 | bytes()       | float()     | iter()       | print()    | tuple()        |
 | callable()    | format()    | len()        | property() | type()         |
 | chr()         | frozenset() | list()       | range()    | vars()         |
 | classmethod() | getattr()   | locals()     | repr()     | zip()          |
 | compile()     | globals()   | map()        | reversed() | __import__()   |
 | complex()     | hasattr()   | max()        | round()    |                |
 | delattr()     | hash()      | memoryview() | set()      |                |
 |               |             |              |            |                |
   #+END_QUOTE

** Assert methods

   Method                 Checks that          New in     
   assertEqual(a, b)      a == b                          
   assertNotEqual(a, b)   a != b                          
   assertTrue(x)          bool(x) is True                 
   assertFalse(x)         bool(x) is False                
   assertIs(a, b)         a is b               3.1        
   assertIsNot(a, b)      a is not b           3.1        
   assertIsNone(x)        x is None            3.1        
   assertIsNotNone(x)     x is not None        3.1        
   assertIn(a, b)         a in b               3.1        
   assertNotIn(a, b)      a not in b           3.1        
   assertIsInstance(a, b) isinstance(a, b)     3.2        
   assertNotIsInstance(a, b) not isinstance(a, b) 3.2        

   


* Methodology
  Seems like the best approach is to test each function and ensure how they work.

** Template
   Lets create a mold for pouring by the test suits:

   #+BEGIN_EXAMPLE
   #+BEGIN_SRC python :noweb yes :tangle tests/test_built-in_functions.py
   """Discover how they work by a coherent testing"""
   <<import-header>>


   <<abs-test-suite>>

   
   <<all-test-suite>>


   <<any-test-suite>>


   <<all-test-classes-included>>
   #+END_SRC
   #+END_EXAMPLE

   #+BEGIN_SRC python :noweb yes :tangle tests/test_built-in_functions.py :exports none
   """Discover how they work by a coherent testing"""
   <<import-header>>


   <<abs-test-suite>>

   
   <<all-test-suite>>


   <<any-test-suite>>


   <<ascii-test-suite>>


   <<bin-test-suite>>


   <<bool-test-suite>>


   <<bytearray-test-suite>>


   <<bytes-test-suite>>
   #+END_SRC   


   #+BEGIN_QUOTE
   *Tip* Use =C-c C-v t= to generate /(tangle)/ the test file
   #+END_QUOTE

** Necessary imports
   It's clear that you expected to test built-in functions of stdlib
   by means the =unittest= module:

   #+NAME: import-header
   #+BEGIN_SRC python
   import unittest
   #+END_SRC

** Test suits
   Each test case class as a separate source code block with a
   particular name for substitution into template.

*** abs()

    #+NAME: abs-test-suite
    #+BEGIN_SRC python
      class TestAbs(unittest.TestCase):

          def test_positive(self):
              self.assertTrue(abs(4) == 4)

          def test_negative(self):
              self.assertFalse(abs(-4) == -4)

          def test_string_as_argument(self):
              self.assertRaises(TypeError, lambda x: abs('A'))
    #+END_SRC

*** all()
    
   #+NAME: all-test-suite
   #+BEGIN_SRC python
     class TestAll(unittest.TestCase):

         def test_one_value_is_zero(self):
             self.assertFalse(all([0, 1]))

         def test_all_values_are_positive_numbers(self):
             self.assertTrue(all([1, 2, 3]))

         def test_single_element_is_false(self):
             self.assertFalse(all([False, 3]))

         def test_single_element_is_None(self):
             self.assertFalse(all([None, 3]))

         def test_all_values_are_negative(self):
             self.assertTrue(all([-1, -2]))

         def test_all_values_are_strings(self):
             self.assertTrue(all(["String", "value"]))

         def test_one_value_is_empty_string(self):
             self.assertFalse(all(["", "Empty"]))

         def test_empty_list(self):
             self.assertTrue(all([]))

         def test_string_as_argument(self):
             self.assertTrue(all('l') and all('low') and all('at the'))

         def test_non_iter_argument(self):
             self.assertRaises(TypeError, lambda x: all(11))

         # assertRaises(exception, callable, *args, **kwds)

         def test_bool_argument(self):
             self.assertRaises(TypeError, lambda x: all(True))
   #+END_SRC
    
*** any()

    #+NAME: any-test-suite
    #+BEGIN_SRC python
      class TestAny(unittest.TestCase):

          def test_boolean_arguments(self):
              self.assertTrue(any([True, True]))

          def test_mixed_arguments(self):
              self.assertTrue(any([True, False]))

          def test_all_false_elements(self):
              self.assertFalse(any([False, False]))

          def test_string_as_argument(self):
              self.assertTrue(any("Blasphemy"))

          def test_empty_list(self):
              self.assertFalse(any([]))
    #+END_SRC

    #+RESULTS: any-test-suite

*** ascii()
    #+NAME: ascii-test-suite
    #+BEGIN_SRC python
      class TestAscii(unittest.TestCase):
          def test_list_convertation(self):
              self.assertEqual(ascii(['Several', 'words']),
                               "['Several', 'words']")

      # dictionary is unordered sequence in Python

          def test_dict_convertation_double_quotes(self):
              self.assertNotEqual(ascii({"first": 1, "second": 2}),
                                  '{"first": 1, "second": 2}')

          def test_dict_convertation_double_quotes_unordered(self):
              self.assertNotEqual(ascii({"first": 1, "second": 2}),
                                  '{"second": 2, "first": 1}')

          # tests below have a hidden caveat: it passes SOMETIMES
          # due unpredicted dictionary sequence

          # def test_dict_convertation_single_quotes_ordered(self):
          #     self.assertNotEqual(ascii({"first": 1, "second": 2}),
          #                         "{'first': 1, 'second': 2}")

          # def test_dict_convertation_single_quotes_unordered(self):
          #     self.assertEqual(ascii({"first": 1, "second": 2}),
          #                      "{'second': 2, 'first': 1}")
    #+END_SRC

*** bin()
    #+NAME: bin-test-suite
    #+BEGIN_SRC python
      class TestBin(unittest.TestCase):

          def test_integer_argument(self):
              self.assertEqual(bin(16), '0b10000')

          def test_integer_negative(self):
              self.assertEqual(bin(-16), '-0b10000')

          def test_string_as_argument(self):
              self.assertRaises(TypeError, lambda x: bin("A"))

          def test_float_as_argument(self):
              self.assertRaises(TypeError, lambda x: bin(16.3))
    #+END_SRC

*** bool()
    #+NAME: bool-test-suite
    #+BEGIN_SRC python
      class TestBool(unittest.TestCase):

          def test_numeric_argument(self):
              self.assertTrue(bool(1) and bool(-2))

          def test_zero_or_false_argument(self):
              self.assertFalse(bool(0) and bool(False))

          def test_string_as_argument(self):
              self.assertTrue(bool("Abc"))

          def test_mixed_arguments(self):
              self.assertTrue(bool(["A", False]))
    #+END_SRC

*** bytearray()
    #+NAME: bytearray-test-suite
    #+BEGIN_SRC python
      class TestByteArray(unittest.TestCase):
          def setUp(self):
              self.seq = bytearray([0x13, 0x00, 0x00, 0x07, 0x08, 0x00])

          def test_iterable_of_bytes(self):
              self.assertEqual(self.seq.pop(), 0)
              self.assertEqual(self.seq.pop(), 8)

          def test_pop_the_last_item(self):
              self.seq.append(0x09)
              self.assertEqual(self.seq.pop(), 9)

          def test_string_as_argument(self):
              self.assertRaises(TypeError, lambda: self.seq.append('Foo'))
              # it's array of integers from zero to 255

          def test_unsupported_value(self):
              self.assertRaises(ValueError, lambda: self.seq.append(0x257))

          def test_arbitrary_variable(self):
              self.assertEqual(self.seq.pop(1), 0)
              self.assertEqual(self.seq.pop(1), 0)
              self.assertEqual(self.seq.pop(1), 7)

          def tearDown(self):
              self.seq.clear()
    #+END_SRC


** Test runner
   Accustomed unittest as Python module:


   #+BEGIN_SRC sh :results output :exports both
     python -m unittest tests/test_built-in_functions.py

   #+END_SRC

   #+RESULTS:
   : ...................................
   : ----------------------------------------------------------------------
   : Ran 35 tests in 0.004s
   : 
   : OK


* Conclusion
  Now it is totally clear how to compose tests for Python standard
  library testing in a literate programming style.
