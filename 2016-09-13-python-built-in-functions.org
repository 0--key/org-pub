#+BEGIN_HTML
---
layout: post
title: Python
tagline: " built-in functions in TDD"
permalink: /python/stdlib/python-built-in-functions.html
categories: [python, stdlib, TDD, literate programming]
tags: [built-in functions, unittest]
---
#+END_HTML
#+OPTIONS: tags:nil num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t

#+TOC: headlines 3

* Preamble
  In most cases the best approach to study how something works is to
  test its behavior in various circumstances. In a helicopter view it
  is a dissection or a scrutiny.

  The same approach for studying programming language has a plethora
  benefits and the most significant is that it take you chance to play
  with code. Of cause studying by playing is a most natural way of
  learning.

* Documentation
  At [[https://docs.python.org/3/library/functions.html][official web-site]].

  The Python interpreter has a number of functions and types built into
  it that are always available. They are listed here in alphabetical
  order.

** Built-ins
   #+BEGIN_QUOTE
                            *Built-in Functions*
 | abs()         | dict()      | help()       | min()      | setattr()      |
 | all()         | dir()       | hex()        | next()     | slice()        |
 | any()         | divmod()    | id()         | object()   | sorted()       |
 | ascii()       | enumerate() | input()      | oct()      | staticmethod() |
 | bin()         | eval()      | int()        | open()     | str()          |
 | bool()        | exec()      | isinstance() | ord()      | sum()          |
 | bytearray()   | filter()    | issubclass() | pow()      | super()        |
 | bytes()       | float()     | iter()       | print()    | tuple()        |
 | callable()    | format()    | len()        | property() | type()         |
 | chr()         | frozenset() | list()       | range()    | vars()         |
 | classmethod() | getattr()   | locals()     | repr()     | zip()          |
 | compile()     | globals()   | map()        | reversed() | __import__()   |
 | complex()     | hasattr()   | max()        | round()    |                |
 | delattr()     | hash()      | memoryview() | set()      |                |
 |               |             |              |            |                |
   #+END_QUOTE

** Assert methods
#+BEGIN_QUOTE

| Method                    | Checks that          | New in |
|---------------------------+----------------------+--------|
| assertEqual(a, b)         | a == b               |        |
| assertNotEqual(a, b)      | a != b               |        |
| assertTrue(x)             | bool(x) is True      |        |
| assertFalse(x)            | bool(x) is False     |        |
| assertIs(a, b)            | a is b               |    3.1 |
| assertIsNot(a, b)         | a is not b           |    3.1 |
| assertIsNone(x)           | x is None            |    3.1 |
| assertIsNotNone(x)        | x is not None 3.1    |        |
| assertIn(a, b)            | a in b               |    3.1 |
| assertNotIn(a, b)         | a not in b           |    3.1 |
| assertIsInstance(a, b)    | isinstance(a, b)     |    3.2 |
| assertNotIsInstance(a, b) | not isinstance(a, b) |    3.2 |

#+END_QUOTE   


* Methodology
  Seems like the best approach is to test each function and ensure how
  they work.

** Template
   Lets create a mold for pouring by the test suits:

   #+BEGIN_EXAMPLE
   #+BEGIN_SRC python :noweb yes :tangle tests/test_built-in_functions.py
   """Discover how they work by a coherent testing"""
   <<import-header>>
   # two lines between partitions isolate classes by PEP8


   <<abs-test-suite>>

   
   <<all-test-suite>>


   <<any-test-suite>>


   <<all-test-classes-included>>
   #+END_SRC
   #+END_EXAMPLE

   #+BEGIN_SRC python :noweb yes :tangle tests/test_built-in_functions.py :exports none
   """Discover how they work by a coherent testing"""
   <<import-header>>


   <<abs-test-suite>>

   
   <<all-test-suite>>


   <<any-test-suite>>


   <<ascii-test-suite>>


   <<bin-test-suite>>


   <<bool-test-suite>>


   <<bytearray-test-suite>>


   <<bytes-test-suite>>


   <<callable-test-suite>>


   <<chr-test-suite>>


   <<classmethod-test-suite>>


   <<compile-test-suite>>


   <<complex-test-suite>>
   #+END_SRC   


   #+BEGIN_QUOTE
   *Tip* Use =C-c C-v t= to generate /(tangle)/ the test file
   #+END_QUOTE

** Necessary imports
   It's clear that you expected to test built-in functions of stdlib
   by means the =unittest= module:

   #+NAME: import-header
   #+BEGIN_SRC python
   import unittest
   #+END_SRC

** Test suits
   Each test case class as a separate source code block with a
   particular name for substitution into template.

*** abs()

    #+NAME: abs-test-suite
    #+BEGIN_SRC python
      class TestAbs(unittest.TestCase):

          def test_positive(self):
              self.assertTrue(abs(4) == 4)

          def test_negative(self):
              self.assertFalse(abs(-4) == -4)

          def test_string_as_argument(self):
              self.assertRaises(TypeError, lambda: abs('A'))
    #+END_SRC

*** all()
    
   #+NAME: all-test-suite
   #+BEGIN_SRC python
     class TestAll(unittest.TestCase):

         def test_one_value_is_zero(self):
             self.assertFalse(all([0, 1]))

         def test_all_values_are_positive_numbers(self):
             self.assertTrue(all([1, 2, 3]))

         def test_single_element_is_false(self):
             self.assertFalse(all([False, 3]))

         def test_single_element_is_None(self):
             self.assertFalse(all([None, 3]))

         def test_all_values_are_negative(self):
             self.assertTrue(all([-1, -2]))

         def test_all_values_are_strings(self):
             self.assertTrue(all(["String", "value"]))

         def test_one_value_is_empty_string(self):
             self.assertFalse(all(["", "Empty"]))

         def test_empty_list(self):
             self.assertTrue(all([]))

         def test_string_as_argument(self):
             self.assertTrue(all('l') and all('low') and all('at the'))

         def test_non_iter_argument(self):
             self.assertRaises(TypeError, lambda: all(11))

         # assertRaises(exception, callable, *args, **kwds)

         def test_bool_argument(self):
             self.assertRaises(TypeError, lambda: all(True))
   #+END_SRC
    
*** any()

    #+NAME: any-test-suite
    #+BEGIN_SRC python
      class TestAny(unittest.TestCase):

          def test_boolean_arguments(self):
              self.assertTrue(any([True, True]))

          def test_mixed_arguments(self):
              self.assertTrue(any([True, False]))

          def test_all_false_elements(self):
              self.assertFalse(any([False, False]))

          def test_string_as_argument(self):
              self.assertTrue(any("Blasphemy"))

          def test_empty_list(self):
              self.assertFalse(any([]))
    #+END_SRC

    #+RESULTS: any-test-suite

*** ascii()
    #+NAME: ascii-test-suite
    #+BEGIN_SRC python
      class TestAscii(unittest.TestCase):
          def test_list_convertation(self):
              self.assertEqual(ascii(['Several', 'words']),
                               "['Several', 'words']")

      # dictionary is unordered sequence in Python

          def test_dict_convertation_double_quotes(self):
              self.assertNotEqual(ascii({"first": 1, "second": 2}),
                                  '{"first": 1, "second": 2}')

          def test_dict_convertation_double_quotes_unordered(self):
              self.assertNotEqual(ascii({"first": 1, "second": 2}),
                                  '{"second": 2, "first": 1}')

      # tests below have a HIDDEN CAVEAT: it might pass SOMETIMES
      # due undefined dictionary sequence

      # def test_dict_convertation_single_quotes_ordered(self):
      #     self.assertNotEqual(ascii({"first": 1, "second": 2}),
      #                         "{'first': 1, 'second': 2}")

      # def test_dict_convertation_single_quotes_unordered(self):
      #     self.assertEqual(ascii({"first": 1, "second": 2}),
      #                      "{'second': 2, 'first': 1}")
    #+END_SRC

*** bin()
    #+NAME: bin-test-suite
    #+BEGIN_SRC python
      class TestBin(unittest.TestCase):

          def test_integer_argument(self):
              self.assertEqual(bin(16), '0b10000')

          def test_integer_negative(self):
              self.assertEqual(bin(-16), '-0b10000')

          def test_string_as_argument(self):
              self.assertRaises(TypeError, lambda: bin("A"))

          def test_float_as_argument(self):
              self.assertRaises(TypeError, lambda: bin(16.3))
    #+END_SRC

*** bool()
    #+NAME: bool-test-suite
    #+BEGIN_SRC python
      class TestBool(unittest.TestCase):

          def test_numeric_argument(self):
              self.assertTrue(bool(1) and bool(-2) and bool(1.3))

          def test_zero_or_false_argument(self):
              self.assertFalse(bool(0) and bool(False))

          def test_string_as_argument(self):
              self.assertTrue(bool("Abc"))

          def test_mixed_arguments_list(self):
              self.assertTrue(bool(["A", False]))
    #+END_SRC

*** bytearray()
    #+NAME: bytearray-test-suite
    #+BEGIN_SRC python
      class TestByteArray(unittest.TestCase):
          def setUp(self):
              self.seq = bytearray([0x13, 0x00, 0x00, 0x07, 0x08, 0x00])

          def test_as_iterable_of_bytes(self):
              self.assertEqual(self.seq.pop(), 0)
              self.assertEqual(self.seq.pop(), 8)

          def test_add_and_pop_item(self):
              self.seq.append(0x09)
              self.assertEqual(self.seq.pop(), 9)

          def test_string_as_argument(self):
              self.assertRaises(TypeError, lambda: self.seq.append('Foo'))
              # it's should be an array of integers from zero to 255

          def test_unsupported_value(self):
              self.assertRaises(ValueError, lambda: self.seq.append(0x257))

          def test_arbitrary_array_member(self):
              self.assertEqual(self.seq.pop(1), 0)
              self.assertEqual(self.seq.pop(1), 0)
              self.assertEqual(self.seq.pop(1), 7)

          def tearDown(self):
              self.seq.clear()
    #+END_SRC

*** bytes()
    #+NAME: bytes-test-suite
    #+BEGIN_SRC python
      class TestBytes(unittest.TestCase):
          """By definition it is an immutable byte sequence"""

          def setUp(self):
              self.seq = bytes([0x13, 0x00, 0x00, 0x07, 0x08, 0x00])

          def test_count(self):
              self.assertEqual(self.seq.count(0, 2), 2)

          def test_find_bytes(self):
              self.assertEqual(self.seq.find(7), 3)

          def test_index(self):
              self.assertRaises(ValueError, lambda: self.seq.index(11))

          def test_is_digit(self):
              self.assertFalse(self.seq.isalnum())
    #+END_SRC

*** callable()
    #+NAME: callable-test-suite
    #+BEGIN_SRC python
      class TestCallable(unittest.TestCase):

          def sample_function():
              return True

          def test_anonimous_function(self):
              self.assertTrue(callable(lambda: 3 + 2))

          def test_built_in_function(self):
              self.assertFalse(callable(abs(2)))

          def test_string_as_argument(self):
              self.assertFalse(callable("Ismael"))

          def test_numeric_argument(self):
              self.assertFalse(callable(2))

          def test_sample_function(self):
              self.assertTrue(self.sample_function)
    #+END_SRC

*** chr()
    #+NAME: chr-test-suite
    #+BEGIN_SRC python
      class TestChr(unittest.TestCase):

          def test_string_as_argument(self):
              self.assertRaises(TypeError, lambda: chr("Ismael"))

          def test_numeric_argument(self):
              self.assertEqual(chr(2), '\x02')
              self.assertEqual(chr(105), 'i')
    #+END_SRC

*** classmethod() and staticmethod()

*** compile()
    #+NAME: compile-test-suite
    #+BEGIN_SRC python
    
    #+END_SRC

*** complex()
    #+NAME: complex-test-suite
    #+BEGIN_SRC python
      class TestComplex(unittest.TestCase):

          def test_summ_two_arguments(self):
              self.assertEqual(complex(3, 3) + complex(2, 2),
                               complex(5, 5))

          def test_string_as_argument(self):
              self.assertRaises(ValueError, lambda: complex("Alioth"))
    #+END_SRC

** Test runner
   Accustomed unittest as Python module:


   #+BEGIN_SRC sh :results output :exports both
     python -m unittest tests/test_built-in_functions.py

   #+END_SRC

   #+RESULTS:
   : ................................................
   : ----------------------------------------------------------------------
   : Ran 48 tests in 0.005s
   : 
   : OK


* Conclusion
  Now it is totally clear how to compose tests for Python standard
  library testing in a literate programming style.
