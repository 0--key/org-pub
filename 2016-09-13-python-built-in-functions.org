#+BEGIN_HTML
---
layout: post
title: Python
tagline: " built-in functions in TDD"
permalink: /python/stdlib/python-built-in-functions.html
categories: [python, stdlib, TDD, literate programming]
tags: [built-in functions, unittest]
---
#+END_HTML
#+STARTUP: showall
#+OPTIONS: tags:nil num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t

#+TOC: headlines 3

* Preamble
  In most cases the best approach to study how something works is to
  test its behavior in various circumstances. In a helicopter view it
  is a dissection or a scrutiny.

  The same approach for studying programming language has a plethora
  benefits and the most significant is that it take you chance to play
  with code. Of cause studying by playing is a most natural way of
  learning.

* Documentation
  At [[https://docs.python.org/3/library/functions.html][official web-site]].

  The Python interpreter has a number of functions and types built into
  it that are always available. They are listed here in alphabetical
  order.

** Built-ins
   #+BEGIN_QUOTE
                            *Built-in Functions*
 | abs()         | dict()      | help()       | min()      | setattr()      |
 | all()         | dir()       | hex()        | next()     | slice()        |
 | any()         | divmod()    | id()         | object()   | sorted()       |
 | ascii()       | enumerate() | input()      | oct()      | staticmethod() |
 | bin()         | eval()      | int()        | open()     | str()          |
 | bool()        | exec()      | isinstance() | ord()      | sum()          |
 | bytearray()   | filter()    | issubclass() | pow()      | super()        |
 | bytes()       | float()     | iter()       | print()    | tuple()        |
 | callable()    | format()    | len()        | property() | type()         |
 | chr()         | frozenset() | list()       | range()    | vars()         |
 | classmethod() | getattr()   | locals()     | repr()     | zip()          |
 | compile()     | globals()   | map()        | reversed() | __import__()   |
 | complex()     | hasattr()   | max()        | round()    |                |
 | delattr()     | hash()      | memoryview() | set()      |                |
 |               |             |              |            |                |
   #+END_QUOTE

** Assert methods
#+BEGIN_QUOTE

| Method                    | Checks that          | New in |
|---------------------------+----------------------+--------|
| assertEqual(a, b)         | a == b               |        |
| assertNotEqual(a, b)      | a != b               |        |
| assertTrue(x)             | bool(x) is True      |        |
| assertFalse(x)            | bool(x) is False     |        |
| assertIs(a, b)            | a is b               |    3.1 |
| assertIsNot(a, b)         | a is not b           |    3.1 |
| assertIsNone(x)           | x is None            |    3.1 |
| assertIsNotNone(x)        | x is not None 3.1    |        |
| assertIn(a, b)            | a in b               |    3.1 |
| assertNotIn(a, b)         | a not in b           |    3.1 |
| assertIsInstance(a, b)    | isinstance(a, b)     |    3.2 |
| assertNotIsInstance(a, b) | not isinstance(a, b) |    3.2 |

#+END_QUOTE   


* Methodology
  Seems like the best approach is to test each function and ensure how
  they work.

** Template
   Lets create a mold for pouring by the test suits:

   #+BEGIN_EXAMPLE
   #+BEGIN_SRC python :noweb yes :tangle tests/test_built-in_functions.py
   """Discover how they work by a coherent testing"""
   <<import-header>>
   # two lines between partitions isolate classes by PEP8


   <<abs-test-suite>>

   
   <<all-test-suite>>


   <<any-test-suite>>


   <<all-test-classes-included>>
   #+END_SRC
   #+END_EXAMPLE

   #+BEGIN_SRC python :noweb yes :tangle tests/test_built-in_functions.py :exports none
   """Discover how they work by a coherent testing"""
   <<import-header>>


   <<abs-test-suite>>

   
   <<all-test-suite>>


   <<any-test-suite>>


   <<ascii-test-suite>>


   <<bin-test-suite>>


   <<bool-test-suite>>


   <<bytearray-test-suite>>


   <<bytes-test-suite>>


   <<callable-test-suite>>


   <<chr-test-suite>>


   <<classmethod-test-suite>>


   <<compile-test-suite>>


   <<complex-test-suite>>


   <<delattr-test-suite>>


   <<dict-test-suite>>


   <<dir-test-suite>>


   <<divmod-test-suite>>


   <<enumerate-test-suite>>


   <<eval-test-suite>>


   <<exec-test-suite>>


   <<filter-test-suite>>


   <<float-test-suite>>


   <<format-test-suite>>


   <<frozenset-test-suite>>


   <<getattr-test-suite>>


   <<globals-test-suite>>


   <<hasattr-test-suite>>


   <<hash-test-suite>>


   <<help-test-suite>>


   <<hex-test-suite>>


   <<id-test-suite>>


   <<id-test-suite>>


   <<input-test-suite>>


   <<int-test-suite>>


   <<isinstance-test-suite>>


   <<issubclass-test-suite>>


   <<iter-test-suite>>


   <<len-test-suite>>


   <<list-test-suite>>


   <<locals-test-suite>>


   <<map-test-suite>>


   <<max-test-suite>>


   <<memoryview-test-suite>>


   <<min-test-suite>>


   <<next-test-suite>>


   <<object-test-suite>>


   <<oct-test-suite>>


   <<open-test-suite>>


   <<ord-test-suite>>


   <<pow-test-suite>>


   <<print-test-suite>>


   <<property-test-suite>>


   <<range-test-suite>>


   <<repr-test-suite>>


   <<reversed-test-suite>>


   <<round-test-suite>>


   <<set-test-suite>>


   <<setattr-test-suite>>


   <<slice-test-suite>>


   <<sorted-test-suite>>


   <<staticmethod-test-suite>>


   <<str-test-suite>>


   <<sum-test-suite>>


   <<super-test-suite>>


   <<tuple-test-suite>>


   <<type-test-suite>>


   <<vars-test-suite>>


   <<zip-test-suite>>


   <<__import__-test-suite>>
   #+END_SRC   


   #+BEGIN_QUOTE
   *Tip* Use =C-c C-v t= to generate /(tangle)/ the test file
   #+END_QUOTE

** Necessary imports
   It's clear that you expected to test built-in functions of stdlib
   by means the =unittest= module:

   #+NAME: import-header
   #+BEGIN_SRC python
   import unittest
   #+END_SRC

** Test suits
   Each test case class as a separate source code block with a
   particular name for substitution into template.

*** abs()

    #+NAME: abs-test-suite
    #+BEGIN_SRC python
      class TestAbs(unittest.TestCase):

          def test_positive(self):
              self.assertTrue(abs(4) == 4)

          def test_negative(self):
              self.assertFalse(abs(-4) == -4)

          def test_string_as_argument(self):
              self.assertRaises(TypeError, lambda: abs('A'))
    #+END_SRC

*** all()
    
   #+NAME: all-test-suite
   #+BEGIN_SRC python
     class TestAll(unittest.TestCase):

         def test_one_value_is_zero(self):
             self.assertFalse(all([0, 1]))

         def test_all_values_are_positive_numbers(self):
             self.assertTrue(all([1, 2, 3]))

         def test_single_element_is_false(self):
             self.assertFalse(all([False, 3]))

         def test_single_element_is_None(self):
             self.assertFalse(all([None, 3]))

         def test_all_values_are_negative(self):
             self.assertTrue(all([-1, -2]))

         def test_all_values_are_strings(self):
             self.assertTrue(all(["String", "value"]))

         def test_one_value_is_empty_string(self):
             self.assertFalse(all(["", "Empty"]))

         def test_empty_list(self):
             self.assertTrue(all([]))

         def test_string_as_argument(self):
             self.assertTrue(all('l') and all('low') and all('at the'))

         def test_non_iter_argument(self):
             self.assertRaises(TypeError, lambda: all(11))

         # assertRaises(exception, callable, *args, **kwds)

         def test_bool_argument(self):
             self.assertRaises(TypeError, lambda: all(True))
   #+END_SRC
    
*** any()

    #+NAME: any-test-suite
    #+BEGIN_SRC python
      class TestAny(unittest.TestCase):

          def test_boolean_arguments(self):
              self.assertTrue(any([True, True]))

          def test_mixed_arguments(self):
              self.assertTrue(any([True, False]))

          def test_all_false_elements(self):
              self.assertFalse(any([False, False]))

          def test_string_as_argument(self):
              self.assertTrue(any("Blasphemy"))

          def test_empty_list(self):
              self.assertFalse(any([]))
    #+END_SRC

    #+RESULTS: any-test-suite

*** ascii()
    #+NAME: ascii-test-suite
    #+BEGIN_SRC python
      class TestAscii(unittest.TestCase):
          def test_list_convertation(self):
              self.assertEqual(ascii(['Several', 'words']),
                               "['Several', 'words']")

      # dictionary is unordered sequence in Python

          def test_dict_convertation_double_quotes(self):
              self.assertNotEqual(ascii({"first": 1, "second": 2}),
                                  '{"first": 1, "second": 2}')

          def test_dict_convertation_double_quotes_unordered(self):
              self.assertNotEqual(ascii({"first": 1, "second": 2}),
                                  '{"second": 2, "first": 1}')

      # tests below have a HIDDEN CAVEAT: it might pass SOMETIMES
      # due undefined dictionary sequence

      # def test_dict_convertation_single_quotes_ordered(self):
      #     self.assertNotEqual(ascii({"first": 1, "second": 2}),
      #                         "{'first': 1, 'second': 2}")

      # def test_dict_convertation_single_quotes_unordered(self):
      #     self.assertEqual(ascii({"first": 1, "second": 2}),
      #                      "{'second': 2, 'first': 1}")
    #+END_SRC

*** bin()
    #+NAME: bin-test-suite
    #+BEGIN_SRC python
      class TestBin(unittest.TestCase):

          def test_integer_argument(self):
              self.assertEqual(bin(16), '0b10000')

          def test_integer_negative(self):
              self.assertEqual(bin(-16), '-0b10000')

          def test_string_as_argument(self):
              self.assertRaises(TypeError, lambda: bin("A"))

          def test_float_as_argument(self):
              self.assertRaises(TypeError, lambda: bin(16.3))
    #+END_SRC

*** bool()
    #+NAME: bool-test-suite
    #+BEGIN_SRC python
      class TestBool(unittest.TestCase):

          def test_numeric_argument(self):
              self.assertTrue(bool(1) and bool(-2) and bool(1.3))

          def test_zero_or_false_argument(self):
              self.assertFalse(bool(0) and bool(False))

          def test_string_as_argument(self):
              self.assertTrue(bool("Abc"))

          def test_mixed_arguments_list(self):
              self.assertTrue(bool(["A", False]))
    #+END_SRC

*** bytearray()
    #+NAME: bytearray-test-suite
    #+BEGIN_SRC python
      class TestByteArray(unittest.TestCase):
          def setUp(self):
              self.seq = bytearray([0x13, 0x00, 0x00, 0x07, 0x08, 0x00])

          def test_as_iterable_of_bytes(self):
              self.assertEqual(self.seq.pop(), 0)
              self.assertEqual(self.seq.pop(), 8)

          def test_add_and_pop_item(self):
              self.seq.append(0x09)
              self.assertEqual(self.seq.pop(), 9)

          def test_string_as_argument(self):
              self.assertRaises(TypeError, lambda: self.seq.append('Foo'))
              # it's should be an array of integers from zero to 255

          def test_unsupported_value(self):
              self.assertRaises(ValueError, lambda: self.seq.append(0x257))

          def test_arbitrary_array_member(self):
              self.assertEqual(self.seq.pop(1), 0)
              self.assertEqual(self.seq.pop(1), 0)
              self.assertEqual(self.seq.pop(1), 7)

          def tearDown(self):
              self.seq.clear()
    #+END_SRC

*** bytes()
    #+NAME: bytes-test-suite
    #+BEGIN_SRC python
      class TestBytes(unittest.TestCase):
          """By definition it is an immutable byte sequence"""

          def setUp(self):
              self.seq = bytes([0x13, 0x00, 0x00, 0x07, 0x08, 0x00])

          def test_count(self):
              self.assertEqual(self.seq.count(0, 2), 2)

          def test_find_bytes(self):
              self.assertEqual(self.seq.find(7), 3)

          def test_index(self):
              self.assertRaises(ValueError, lambda: self.seq.index(11))

          def test_is_digit(self):
              self.assertFalse(self.seq.isalnum())
    #+END_SRC

*** callable()
    #+NAME: callable-test-suite
    #+BEGIN_SRC python
      class TestCallable(unittest.TestCase):

          def sample_function():
              return True

          def test_anonimous_function(self):
              self.assertTrue(callable(lambda: 3 + 2))

          def test_built_in_function(self):
              self.assertFalse(callable(abs(2)))

          def test_string_as_argument(self):
              self.assertFalse(callable("Ismael"))

          def test_numeric_argument(self):
              self.assertFalse(callable(2))

          def test_sample_function(self):
              self.assertTrue(self.sample_function)
    #+END_SRC

*** chr()
    #+NAME: chr-test-suite
    #+BEGIN_SRC python
      class TestChr(unittest.TestCase):

          def test_string_as_argument(self):
              self.assertRaises(TypeError, lambda: chr("Ismael"))

          def test_numeric_argument(self):
              self.assertEqual(chr(2), '\x02')
              self.assertEqual(chr(105), 'i')
    #+END_SRC

*** classmethod() and staticmethod()

*** compile()
    #+NAME: compile-test-suite
    #+BEGIN_SRC python
    
    #+END_SRC

*** complex()
    #+NAME: complex-test-suite
    #+BEGIN_SRC python
      class TestComplex(unittest.TestCase):

          def test_summ_two_arguments(self):
              self.assertEqual(complex(3, 3) + complex(2, 2),
                               complex(5, 5))

          def test_string_as_argument(self):
              self.assertRaises(ValueError, lambda: complex("Alioth"))
    #+END_SRC
    
*** delattr()
    #+NAME: delattr-test-suite
    #+BEGIN_SRC python
      class TestDelattr(unittest.TestCase):

          def setUp(self):
              """Create a mockup object for testing purposes"""
              class Pear():
                  def __init__(self):
                      self.size = 123
                      self.color = 'green'

              self.obj = Pear()

          def test_all_obj_attributes(self):
              self.assertTrue(self.obj.size and self.obj.color)

          def test_del_existing_attribute(self):
              self.assertIsNone(delattr(self.obj, 'size'))
              self.assertRaises(AttributeError, lambda: self.obj.size)

          def test_del_non_existing_attribute(self):
              self.assertRaises(AttributeError,
                                lambda: delattr(self.obj, 'shape'))
    #+END_SRC

*** TODO dict()
    #+NAME: dict-test-suite
    #+BEGIN_SRC python
      class TestDict(unittest.TestCase):

          def setUp(self):
              """Create a mockup object for testing purposes"""
              class Pear():
                  def __init__(self):
                      self.size = 123
                      self.color = 'green'

              self.obj = Pear()
              self.mock_dict = dict(a=1, b=2)

          def test_all_dict_attributes(self):
              self.assertTrue(self.mock_dict["a"] == 1)
              self.assertTrue(self.mock_dict["b"] == 2)

          # def test_mapping_obj(self):
          #     #
          #     self.assertTrue(dict(self.obj))
          #     # self.assertRaises(AttributeError, lambda: self.obj.size)
    #+END_SRC

*** dir()
    #+NAME: dir-test-suite
    #+BEGIN_SRC python
      class TestDir(unittest.TestCase):

          def setUp(self):
              """Create a mockup object for testing purposes"""
              class Pear():
                  def __init__(self):
                      self.size = 123
                      self.color = 'green'

              self.obj = Pear()

          def test_existing_attr(self):
              self.assertTrue(dir(self.obj)[-1] == 'size' and
                              dir(self.obj)[-2] == 'color')
    #+END_SRC

*** divmod()
    #+NAME: divmod-test-suite
    #+BEGIN_SRC python
      class TestDivmod(unittest.TestCase):

          def test_simple_division(self):
              self.assertTrue(divmod(5, 3) == (1, 2))

          def test_complex_division(self):
              self.assertTrue(divmod(10, 3) == (3, 1))
    #+END_SRC

*** enumerate()
    #+NAME: enumerate-test-suite
    #+BEGIN_SRC python
      class TestEnumerate(unittest.TestCase):

          def test_enumerate_zero_list(self):
              """function returns an iterator"""
              alist = [0, 1, 2]
              for i, j in enumerate(alist):
                  self.assertEqual(i, j)

          def test_enumerate_arbitrary_list(self):
              alist = [2, 3, 4]
              for i, j in enumerate(alist, 2):
                  self.assertEqual(i, j)
    #+END_SRC

*** eval()
    #+NAME: eval-test-suite
    #+BEGIN_SRC python
      class TestEval(unittest.TestCase):

          def test_strict_addition(self):
              self.assertTrue(eval('2 + 2') == 4)

          def test_wrong_type_argument(self):
              """eval() arg 1 must be a string, bytes or code object"""
              self.assertRaises(TypeError, lambda: eval(2 + 2))
    #+END_SRC

*** exec()
    #+NAME: exec-test-suite
    #+BEGIN_SRC python
      class TestExec(unittest.TestCase):

          def test_code_execution(self):
              l = []
              code = 'for i in range(3):\n\tl.append(i)\n'
              exec(code)
              self.assertTrue(l == [0, 1, 2])

          def test_wrong_type_argument(self):
              self.assertRaises(TypeError, lambda: exec(2 + 2))
    #+END_SRC

*** filter()
    #+NAME: filter-test-suite
    #+BEGIN_SRC python
      class TestFilter(unittest.TestCase):

          def setUp(self):
              self.f = filter(None, [True, False, None, 0, 1, 2])
              self.ff = filter(None, [False, None, 0])
              self.fc = filter(lambda x: x > 2 and x < 5, range(10))

          def test_simple_filter(self):
              """Accepts the true elements only"""
              result = []
              for j in self.f:
                  result.append(j)
              self.assertEqual(result, [True, 1, 2])

          def test_simple_false_filter(self):
              """False elements are quashed"""
              result = []
              for j in self.ff:
                  result.append(j)
              self.assertEqual(result, [])

          def test_complex_filter(self):
              result = []
              for j in self.fc:
                  result.append(j)
              self.assertEqual(result, [3, 4])
    #+END_SRC

*** float()
    #+NAME: float-test-suite
    #+BEGIN_SRC python
      class TestFloat(unittest.TestCase):

          def test_simple_conversion(self):
              self.assertEqual(float(1), 1.0)

          def test_string_as_argument(self):
              self.assertEqual(float('1.11'), 1.11)

          def test_expression_as_argument(self):
              self.assertEqual(float(1 / 2), 0.5)

          def test_wrong_type_argument(self):
              self.assertRaises(ValueError, lambda: float('Bob and Alice'))
    #+END_SRC

*** format()
    #+NAME: format-test-suite
    #+BEGIN_SRC python
      class TestFormat(unittest.TestCase):
          """http://www.python-course.eu/python3_formatted_output.php"""

          def test_simple_string_formatting(self):
              template = "Just {a} template {b}"
              self.assertEqual(template.format(a='a', b='string'),
                               'Just a template string')

          def test_positional_args_formatting(self):
              template = "This {0} sample {1}"
              self.assertEqual(template.format('is a', 'formatting'),
                               'This is a sample formatting')
    #+END_SRC

*** frozenset()
    #+NAME: frozenset-test-suite
    #+BEGIN_SRC python
      class TestFrozenset(unittest.TestCase):
          """Tuples are immutable lists, frozensets are immutable sets"""

          def test_simple_frozen_set(self):
              self.assertEqual(frozenset('def'), set('def'))

          def test_only_unique_elements(self):
              self.assertEqual(frozenset('defdek'), set('dekdef'))
    #+END_SRC

*** getattr()
    #+NAME: getattr-test-suite
    #+BEGIN_SRC python
      class TestGetattr(unittest.TestCase):
          """Get a named attribute from an object"""

          def setUp(self):
              """Create a mockup object for testing purposes"""
              class Pear():

                  def __init__(self):
                      self.size = 123
                      self.color = 'green'

              self.obj = Pear()

          def test_existing_attr(self):
              self.assertEqual(getattr(self.obj, 'size'), 123)

          def test_non_existing_attr(self):
              self.assertRaises(AttributeError, lambda: getattr(self.obj, 'shape'))

          def test_default_value(self):
              self.assertEqual(getattr(self.obj, 'shape', 'pyramid'), 'pyramid')
    #+END_SRC

*** globals()
    #+NAME: globals-test-suite
    #+BEGIN_SRC python
      class TestGlobals(unittest.TestCase):
          """Return the dictionary containing the current scope's global
          variables
          """

          def test_current_scope_classes(self):
              self.assertTrue('TestGetattr' and 'TestGlobals' in globals())
    #+END_SRC

*** hasattr()
    #+NAME: hasattr-test-suite
    #+BEGIN_SRC python
      class TestHasattr(unittest.TestCase):
          """Return whether the object has an attribute with the given name"""

          def setUp(self):
              """Create a mockup object for testing purposes"""
              class Pear():

                  def __init__(self):
                      self.size = 123
                      self.color = 'green'

              self.obj = Pear()

          def test_existing_attr(self):
              self.assertTrue(hasattr(self.obj, 'size'))

          def test_non_existing_attr(self):
              self.assertFalse(hasattr(self.obj, 'shape'))
    #+END_SRC

*** hash()
    #+NAME: hash-test-suite
    #+BEGIN_SRC python
      class TestHash(unittest.TestCase):
          """Return a hash value for the object"""

          def setUp(self):
              """Create a mockup object for testing purposes"""
              class Pear():

                  def __init__(self):
                      self.size = 123
                      self.color = 'green'

              self.obj1 = Pear()
              self.obj2 = Pear()

          def test_the_same_object(self):
              self.assertEqual(hash(self.obj1), hash(self.obj1))

          def test_different_objects(self):
              """Different objects with equal properties has different
              hashes"""
              self.assertNotEqual(hash(self.obj1), hash(self.obj2))

          def test_equal_attributes(self):
              self.assertEqual(hash(self.obj2.size), hash(self.obj1.size))
    #+END_SRC

*** help()
    #+NAME: help-test-suite
    #+BEGIN_SRC python
      class TestHelp(unittest.TestCase):

          def test_help_on_existing_function(self):
              self.assertIsNone(help(zip))

          def test_help_none_existing_function(self):
              self.assertRaises(NameError, lambda: help(mod))
    #+END_SRC

*** hex()
    #+NAME: hex-test-suite
    #+BEGIN_SRC python
      class TestHex(unittest.TestCase):

          def test_integer_argument(self):
              self.assertEqual(hex(3735928559), '0xdeadbeef')

          def test_float_argument(self):
              self.assertRaises(TypeError, lambda: hex(2.2))
    #+END_SRC

*** id()
    #+NAME: id-test-suite
    #+BEGIN_SRC python
      class TestId(unittest.TestCase):

          def setUp(self):
              """Create a mockup object for testing purposes"""
              class Pear():

                  def __init__(self):
                      self.size = 123
                      self.color = 'green'

              self.obj1 = Pear()
              self.obj2 = self.obj3 = Pear()

          def test_different_objects(self):
              self.assertNotEqual(id(self.obj1), id(self.obj2))

          def test_same_objects(self):
              self.assertEqual(id(self.obj2), id(self.obj3))
    #+END_SRC

*** input()
    #+NAME: input-test-suite
    #+BEGIN_SRC python
      class TestInput(unittest.TestCase):
          """::"""

          def test_tap(self):
              """TODO"""
              self.assertTrue(True)
    #+END_SRC

*** int()
    #+NAME: int-test-suite
    #+BEGIN_SRC python
      class TestInt(unittest.TestCase):

          def test_integer_argument(self):
              self.assertEqual(int(3735928559), 3735928559)

          def test_float_argument(self):
              self.assertEqual(int(2.2), 2)

          def test_float_negative_argument(self):
              self.assertEqual(int(-2.2), -2)

          def test_string_argument(self):
              self.assertRaises(ValueError, lambda: int('a'))
    #+END_SRC
    
*** isinstance()
    #+NAME: isinstance-test-suite
    #+BEGIN_SRC python
      class TestIsinstance(unittest.TestCase):

          def test_argument_type(self):
              self.assertTrue(isinstance('Bob and Alice', str))

          def test_argument_class(self):
              class Pear():
                  pass

              self.obj = Pear()
              self.assertTrue(isinstance(self.obj, Pear))
    #+END_SRC

*** issubclass()
    #+NAME: issubclass-test-suite
    #+BEGIN_SRC python
      class TestIssubclass(unittest.TestCase):

          def test_the_mock_object_direct_relation(self):

              class Fruit():
                  pass

              class Pear(Fruit):
                  pass

              self.assertTrue(issubclass(Pear, Fruit))

          def test_the_mock_object_reverse_relation(self):

              class Fruit():
                  pass

              class Pear(Fruit):
                  pass

              self.assertFalse(issubclass(Fruit, Pear))
    #+END_SRC

*** iter()
    #+NAME: iter-test-suite
    #+BEGIN_SRC python
      class TestIter(unittest.TestCase):

          def setUp(self):
              self.mockup_list = [1, 2, 3]
              self.mockup_string = 'This is EOF the test string'

          def test_strict_iteration(self):
              self.assertTrue(iter(self.mockup_list))

          def test_all_elements_in_sequence(self):
              l = iter(self.mockup_list)
              m = []
              for i in l:
                  m.append(i)
              self.assertEqual(m, [1, 2, 3])

          def test_separate_elements_iteration(self):
              i = iter(self.mockup_list)
              a = next(i)
              b = next(i)
              c = next(i)
              self.assertTrue(a == 1 and b == 2 and c == 3)
    #+END_SRC

*** len()
    #+NAME: len-test-suite
    #+BEGIN_SRC python
      class TestLen(unittest.TestCase):

          def test_lenghth_of_string(self):
              self.assertEqual(len('Ahab'), 4)

          def test_lenghth_of_list(self):
              self.assertEqual(len([1, 2, 3]), 3)
    #+END_SRC

*** list()
    #+NAME: list-test-suite
    #+BEGIN_SRC python
      class TestList(unittest.TestCase):

          def test_simple_list_of_letters(self):
              self.assertEqual(list('Pear'), ['P', 'e', 'a', 'r'])

          def test_convert_tuple_into_list(self):
              self.assertEqual(list((1, 2, 3)), [1, 2, 3])

          def test_convert_dictionary_into_list(self):
              # dictionary is an unordered sequence by its definition
              self.assertTrue(list({'a': 1, 'b': 2}) == ['a', 'b'] or ['b', 'a'])

          def test_not_iterable_argument(self):
              self.assertRaises(TypeError, lambda: list(123.11))
    #+END_SRC

*** locals()
    #+NAME: locals-test-suite
    #+BEGIN_SRC python
      d = {'this': 1, 'is': 2, 'a': 3, 'global': 4, 'variable': 5}


      class TestLocals_and_Globals(unittest.TestCase):

          def setUp(self):
              """Cooke the mixture of objects"""
              self.d = {'the': 1, 'global': 2, 'dictionary': 3}

          def test_string_as_argument(self):
              l = "Just a local variable"
              self.assertEqual(locals()['l'], "Just a local variable")

          def test_reassign_variable(self):
              d = {'a': 1, 'simple': 2, 'dictionary': 3}
              self.assertEqual(locals()['d']['a'], 1)
              self.assertEqual(locals()['d']['simple'], 2)

          def test_global_dict(self):
              self.assertEqual(globals()['d']['this'], 1)
    #+END_SRC

*** map()
    #+NAME: map-test-suite
    #+BEGIN_SRC python
      class TestMap(unittest.TestCase):

          def test_map_under_num_seq(self):
              i = map(lambda x: x * 1.25, [4, 8, 12])
              self.assertTrue(next(i) == 5 and next(i) == 10 and
                              next(i) == 15)
    #+END_SRC

*** max()
    #+NAME: max-test-suite
    #+BEGIN_SRC python
      class TestMax(unittest.TestCase):

          def test_simple_list_of_int(self):
              self.assertTrue(max([1, 2, 3]) == 3)

          def test_simple_list_of_letters(self):
              self.assertTrue(max(['a', 'b', 'c']) == 'c')

          def test_list_of_strings(self):
              self.assertTrue(max('Aaron', 'Bobby', 'Scotty') == 'Scotty')

              def test_string_values_comparison(self):
                  self.assertTrue(max(['1', '100', '111', '2']) == '2')

          def test_with_key_function(self):
              self.assertTrue(max(['1', '100', '111', '2'],
                                  key=lambda x: int(x)) == '111')

          def test_with_key_function_1(self):
              self.assertTrue(max('Aaron', 'Bobby', 'Scotty',
                                  key=lambda x: x[2]) == 'Aaron')
    #+END_SRC

*** memoryview()
    #+NAME: memoryview-test-suite
    #+BEGIN_SRC python
      class TestMemoryview(unittest.TestCase):

          def setUp(self):
              self.v = memoryview(b'abcefg')

          def test_simple_behaviour(self):
              self.assertTrue(self.v[0] == 97 and
                              self.v[-1] == 103)
    #+END_SRC

*** min()
    #+NAME: min-test-suite
    #+BEGIN_SRC python
      class TestMin(unittest.TestCase):

          def test_simple_behaviour_with_string_argument(self):
              self.assertEqual(min('abc'), 'a')

          def test_simple_behaviour_with_list_of_int_argument(self):
              self.assertEqual(min([2, 3, 1]), 1)

          def test_with_key_function(self):
              self.assertTrue(min('Aaron', 'Bobby', 'Scotty',
                                  key=lambda x: x[2]) == 'Bobby')
    #+END_SRC

*** next()
    #+NAME: next-test-suite
    #+BEGIN_SRC python
      class TestNext(unittest.TestCase):

          def setUp(self):
              self.i = iter('abcdef')

          def test_iteration(self):
              self.assertTrue(next(self.i) == 'a' and
                              next(self.i) == 'b')

          def test_continuous_iteration(self):
              self.assertFalse(next(self.i) == 'c')
    #+END_SRC

*** object()
    #+NAME: object-test-suite
    #+BEGIN_SRC python
      class TestObject(unittest.TestCase):
          """The most base type"""

          def setUp(self):
              self.obj = object()

          def test_simple_behaviour(self):
              self.assertTrue(self.obj)
    #+END_SRC
    
*** oct()
    #+NAME: oct-test-suite
    #+BEGIN_SRC python
      class TestOct(unittest.TestCase):

          def test_integer_argument(self):
              self.assertEqual(oct(11), '0o13')

          def test_negative_argument(self):
              self.assertEqual(oct(-11), '-0o13')

          def test_string_argument(self):
              self.assertRaises(TypeError, lambda: oct('a'))
    #+END_SRC

*** open()
    #+NAME: open-test-suite
    #+BEGIN_SRC python
      class TestOpen(unittest.TestCase):

          def test_simple_behaviour(self):
              pass
    #+END_SRC

*** ord()
    #+NAME: ord-test-suite
    #+BEGIN_SRC python
      class TestOrd(unittest.TestCase):

          def test_simple_behaviour(self):
              self.assertTrue(ord('a') == 97)

          def test_wrong_argument(self):
              self.assertRaises(TypeError, lambda: ord('ab'))
    #+END_SRC

*** pow()
    #+NAME: pow-test-suite
    #+BEGIN_SRC python
      class TestPow(unittest.TestCase):

          def test_simple_behaviour(self):
              self.assertEqual(pow(2, 2), 4)

          def test_complex_power(self):
              self.assertAlmostEqual(pow(9, 0.5), 3)

          def test_specific_third_argument(self):
              self.assertTrue(pow(3, 3, 2) == 1)
    #+END_SRC

*** print()
    #+NAME: print-test-suite
    #+BEGIN_SRC python
      class TestPrint(unittest.TestCase):

          def test_simple_behaviour(self):
              self.assertIsNone(print('Hellow World'))
    #+END_SRC

*** TODO property()
    #+NAME: property-test-suite
    #+BEGIN_SRC python
      # class TestProperty(unittest.TestCase):

      #     def setUp(self):
      #         """property(fget=None, fset=None, fdel=None, doc=None) ->
      #         property attribute"""

      #         class C(object):
      #             @property
      #             def x(self):
      #                 "I am the 'x' property."
      #                 return self._x

      #             @x.setter
      #             def x(self, value):
      #                 self._x = value

      #             @x.deleter
      #             def x(self):
      #                 del self._x

      #         class D(object):

      #             def getx(self):
      #                 return self._x

      #             def setx(self, value):
      #                 self._x = value

      #             def delx(self):
      #                 del self._x
      #             x = property(getx, setx, delx, "I'm the 'x' property.")

      #         self.obj_1 = C()
      #         self.obj_2 = D()

      #     def test_simple_behaviour(self):
      #         self.assertEqual(self.obj_1.x, self.obj_2.x)
    #+END_SRC

*** range()
    #+NAME: range-test-suite
    #+BEGIN_SRC python
      class TestRange(unittest.TestCase):

          def setUp(self):
              self.A = range(3)
              self.B = range(3, 10, 2)
              self.C = range(3, 11, 2)
              self.D = range(-3, -10, -2)

          def test_simple_behaviour(self):
              l = []
              for i in self.A:
                  l.append(i)
              self.assertEqual(l, [0, 1, 2])

          def test_with_step(self):
              l = []
              for i in self.B:
                  l.append(i)
              self.assertEqual(l, [3, 5, 7, 9])

          def test_with_step_and_right_exclude(self):
              l = []
              for i in self.C:
                  l.append(i)
              self.assertEqual(l, [3, 5, 7, 9])

          def test_negative_range(self):
              l = []
              for i in self.D:
                  l.append(i)
              self.assertEqual(l, [-3, -5, -7, -9])
    #+END_SRC

*** repr()
    #+NAME: repr-test-suite
    #+BEGIN_SRC python
      class TestRepr(unittest.TestCase):

          def setUp(self):
              class Pear():

                  def __init__(self):
                      self.size = 124
                      self.color = 'green'

                  def __repr__(self):
                      return('This is a particular representation')

              self.obj = Pear()

          def test_simple_behaviour(self):
              self.assertTrue(repr(123) == '123' and
                              repr([1, 2, 3]) == '[1, 2, 3]')

          def test_object_representation(self):
              self.assertTrue(repr(self.obj) ==
                              'This is a particular representation')
    #+END_SRC

*** reversed()
    #+NAME: reversed-test-suite
    #+BEGIN_SRC python
      class TestReversed(unittest.TestCase):
          """reversed(sequence) -> reverse iterator over values of the sequence"""

          def setUp(self):
              self.s = reversed('abc')
              self.d = reversed([1, 2, 3])

          def test_simple_behaviour(self):
              self.assertTrue(next(self.s) == 'c' and
                              next(self.s) == 'b')

          def test_list_as_argument(self):
              self.assertTrue(next(self.d) == 3 and
                              next(self.d) == 2)
    #+END_SRC

*** round()
    #+NAME: round-test-suite
    #+BEGIN_SRC python
      class TestRound(unittest.TestCase):

          def test_simple_behaviour(self):
              self.assertTrue(round(4.6) == 5)

          def test_with_ndigits(self):
              self.assertTrue(round(4.66, 1) == 4.7)

          def test_with_negative_ndigits(self):
              self.assertTrue(round(4.66, -1) == 0.0)
              self.assertTrue(round(444.66, -1) == 440.0)
    #+END_SRC

*** set()
    #+NAME: set-test-suite
    #+BEGIN_SRC python
      class TestSet(unittest.TestCase):

          def test_simple_behaviour(self):
              self.assertTrue(set('abaaba') == set('ab'))

          def test_dictionary_as_argument(self):
              self.assertEqual(set({'a': 1, 'b': 2, 'c': 2, 'b': 3}),
                               {'a', 'b', 'c'})
    #+END_SRC

*** setattr()
    #+NAME: setattr-test-suite
    #+BEGIN_SRC python
      class TestSetattr(unittest.TestCase):

          def setUp(self):
              class Pear():

                  def __init__(self):
                      self.size = 124
                      self.color = 'green'

                  def __repr__(self):
                      return('This is a particular representation')

              self.obj = Pear()

          def test_simple_behaviour(self):
              self.assertTrue(self.obj.size == 124)
              setattr(self.obj, 'size', 125)
              self.assertTrue(self.obj.size == 125)

          def test_inheritance_in_testing(self):
              self.assertFalse(self.obj.size == 125)

          def test_undefined_attribute(self):
              setattr(self.obj, 'shape', 'normal')
              self.assertFalse(self.obj == 'normal')
    #+END_SRC

*** slice()
    #+NAME: slice-test-suite
    #+BEGIN_SRC python
      class TestSlice(unittest.TestCase):

          def setUp(self):
              self.l = [1, 2, 3, 4, 5, 6, 7, 8, 9]

          def test_simple_behaviour(self):
              sl = slice(0, 3)
              self.assertTrue(self.l[sl] == [1, 2, 3])

          def test_default_start_value(self):
              sl = slice(3)
              self.assertTrue(self.l[sl] == [1, 2, 3])

          def test_with_step(self):
              sl = slice(0, 9, 3)
              self.assertTrue(self.l[sl] == [1, 4, 7])
    #+END_SRC

*** sorted()
    #+NAME: sorted-test-suite
    #+BEGIN_SRC python
      class TestSorted(unittest.TestCase):

          def setUp(self):
              self.l = [1, 2, 3, 6, 7, 8, 9, 4, 5]
              self.d = {'a': 1, 'b': 0, 'c': -1}

          def test_simple_behaviour(self):
              self.assertEqual(sorted(self.l),
                               [1, 2, 3, 4, 5, 6, 7, 8, 9])

          def test_dict_sorting(self):
              import operator
              self.assertTrue(sorted(self.d.items(),
                                     key=operator.itemgetter(1)) ==
                              [('c', -1), ('b', 0), ('a', 1)])

          def test_dict_sorting_python3(self):
              # sinonymous and much neat solution
              self.assertTrue(sorted(self.d.items(),
                                     key=lambda x: x[1]) ==
                              [('c', -1), ('b', 0), ('a', 1)])

          def test_reverse_sorting(self):
              self.assertEqual(sorted(self.l, reverse=True),
                               [9, 8, 7, 6, 5, 4, 3, 2, 1])
    #+END_SRC

*** staticmethod()
    #+NAME: staticmethod-test-suite
    #+BEGIN_SRC python
      class TestStaticmethod(unittest.TestCase):

          def setUp(self):
              pass

          def test_simple_behaviour(self):
              self.assertEqual(staticmethod())
    #+END_SRC

*** str()
    #+NAME: str-test-suite
    #+BEGIN_SRC python
      class TestStr(unittest.TestCase):

          def test_simple_behaviour(self):
              self.assertTrue(str([1, 2, 3]) == '[1, 2, 3]')
    #+END_SRC

*** sum()
    #+NAME: sum-test-suite
    #+BEGIN_SRC python
      class TestSum(unittest.TestCase):

          def test_simple_behaviour(self):
              self.assertTrue(sum([1, 2, 3]) == 6)
              self.assertTrue(sum([1.1, 2.2, 3.3]) == 6.6)

          def test_start_value(self):
              self.assertTrue(sum([1, 2, 3], 1) == 7)
              self.assertTrue(sum([1, 2, 3], 2) == 8)

          def test_string_as_argument(self):
              self.assertRaises(TypeError, lambda: sum("abc"))

          def test_list_of_strings_as_argument(self):
              self.assertRaises(TypeError, lambda: sum(['a', 'b', 'c']))
    #+END_SRC

*** super()
    #+NAME: super-test-suite
    #+BEGIN_SRC python
      class TestSuper(unittest.TestCase):

          def test_simple_behaviour(self):

              class Fruit():

                  def sample_method(self):
                      return "It is a parent class' method"

              class Pear(Fruit):

                  def sample_method(self):
                      super().sample_method()
                      # return "This is a native method"

              self.obj = Pear()
              print(self.obj.sample_method())

              self.assertTrue(self.obj.sample_method() ==
                              "It is a parent class' method")
    #+END_SRC

*** tuple()
    #+NAME: tuple-test-suite
    #+BEGIN_SRC python
    
    #+END_SRC

*** type()
    #+NAME: type-test-suite
    #+BEGIN_SRC python
    
    #+END_SRC

*** vars()
    #+NAME: vars-test-suite
    #+BEGIN_SRC python
    
    #+END_SRC

*** zip()
    #+NAME: zip-test-suite
    #+BEGIN_SRC python
    
    #+END_SRC

*** __import__()
    #+NAME: __import__-test-suite
    #+BEGIN_SRC python
    
    #+END_SRC


** Test runner
   Accustomed unittest as Python module:


   #+BEGIN_SRC sh :results output :exports both
     python -m unittest tests/test_built-in_functions.py

   #+END_SRC

   #+RESULTS:
   #+begin_example
   ...................................................................................................................................E........
   ======================================================================
   ERROR: test_simple_behaviour (tests.test_built-in_functions.TestProperty)
   ----------------------------------------------------------------------
   Traceback (most recent call last):
     File "/usr/local/share/DVCS/org-pub/tests/test_built-in_functions.py", line 820, in test_simple_behaviour
       self.assertEqual(self.obj_1.x, self.obj_2.x)
     File "/usr/local/share/DVCS/org-pub/tests/test_built-in_functions.py", line 794, in x
       return self._x
   AttributeError: 'C' object has no attribute '_x'

   ----------------------------------------------------------------------
   Ran 140 tests in 0.107s

   FAILED (errors=1)
   Help on class zip in module builtins:

   class zip(object)
    |  zip(iter1 [,iter2 [...]]) --> zip object
    |  
    |  Return a zip object whose .__next__() method returns a tuple where
    |  the i-th element comes from the i-th iterable argument.  The .__next__()
    |  method continues until the shortest iterable in the argument sequence
    |  is exhausted and then it raises StopIteration.
    |  
    |  Methods defined here:
    |  
    |  __getattribute__(self, name, /)
    |      Return getattr(self, name).
    |  
    |  __iter__(self, /)
    |      Implement iter(self).
    |  
    |  __new__(*args, **kwargs) from builtins.type
    |      Create and return a new object.  See help(type) for accurate signature.
    |  
    |  __next__(self, /)
    |      Implement next(self).
    |  
    |  __reduce__(...)
    |      Return state information for pickling.

   Hellow World
#+end_example


* Conclusion
  Now it is totally clear how to compose tests for Python standard
  library testing in a literate programming style.
