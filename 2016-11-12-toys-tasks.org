#+BEGIN_HTML
---
layout: post
title: Write Python programs
tagline: " by means of Emacs' toolbox"
permalink: /coding/codewars-toy-tasks.html
categories: [literate programming, Python, CodeWars, emacs]
tags: [coding, algorithms]
---
#+END_HTML
#+STARTUP: showall
#+OPTIONS: tags:nil num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t
#+TOC: headlines 2

* #1 Vowels counter
  #+BEGIN_QUOTE
  Return the number (count) of vowels in the given string.
  We will consider a, e, i, o, and u as vowels for this Kata.
  #+END_QUOTE

  #+BEGIN_SRC python :results output
    def getCount(inputStr):
        num_vowels = 0
        # your code here
        for letter in inputStr:
            list_of_vowels = ['a', 'e', 'i', 'o', 'u']
            if letter in list_of_vowels:
                num_vowels += 1
                #print(letter)
                #print(num_vowels)
        return num_vowels

    input_string = 'John the dully boy write this book'

    print getCount(input_string)
    assert(getCount(input_string) == 9)

  #+END_SRC

  #+RESULTS:
  : 9

* #2 Last digit of a large number
  
** Description

   Define a function

   #+BEGIN_SRC python
   def last_digit(n1, n2):
      return   
   #+END_SRC

   #+BEGIN_QUOTE
  that takes in two numbers a and b and returns the last decimal digit of a^b. Note that a and b may be very large!

  For example, the last decimal digit of 9^7 is 9, since 9^7 = 4782969. The last decimal digit of (2^200)^(2^300), which has over 10^92 decimal digits, is 6.

  The inputs to your function will always be non-negative integers.
  Examples

  last_digit(4, 1)                # returns 4
  last_digit(4, 2)                # returns 6
  last_digit(9, 7)                # returns 9
  last_digit(10, 10 ** 10)        # returns 0
  last_digit(2 ** 200, 2 ** 300)  # returns 6

  Remarks
  JavaScript

  Since JavaScript doesn't have native arbitrary large integers, your arguments are going to be strings representing non-negative integers, e.g.

  lastDigit("10", "10000000000");

  The kata is still as hard as the variants for Haskell or Python, don't worry.
   #+END_QUOTE

** Code

*** Visualise the matrix of number's orders
    #+BEGIN_SRC python :results output :pp :exports both
      def simple_array():
       l = []
       for i in range(10):
	l.append([i] + [str(i**j)[-1] for j in range(10)])
       return l

      for i in simple_array():
       print(i)
    #+END_SRC

    #+RESULTS:
    #+begin_example
    [0, '1', '0', '0', '0', '0', '0', '0', '0', '0', '0']
    [1, '1', '1', '1', '1', '1', '1', '1', '1', '1', '1']
    [2, '1', '2', '4', '8', '6', '2', '4', '8', '6', '2']
    [3, '1', '3', '9', '7', '1', '3', '9', '7', '1', '3']
    [4, '1', '4', '6', '4', '6', '4', '6', '4', '6', '4']
    [5, '1', '5', '5', '5', '5', '5', '5', '5', '5', '5']
    [6, '1', '6', '6', '6', '6', '6', '6', '6', '6', '6']
    [7, '1', '7', '9', '3', '1', '7', '9', '3', '1', '7']
    [8, '1', '8', '4', '2', '6', '8', '4', '2', '6', '8']
    [9, '1', '9', '1', '9', '1', '9', '1', '9', '1', '9']
#+end_example

*** Seeking for the sequences
    - Static are 0, 1, 5, 6
      - 0 as an order determiner has deviation from general
	rule
    - Periodic are 2, 3, 4, 7, 8, 9
      - 2: [2, 4, 6, 8]
      - 3: [3, 9, 7, 1]
      - 4: [4, 6, 4]
      - 7: [7, 9, 3, 1]
      - 8: [8, 4, 2, 6]
      - 9: [9, 1]

*** Entire meta-data
    For simplification purposes lets create a full set of rules.
      - 0: [0, 0]
      - 1: [1, 1]
      - 2: [2, 4, 6, 8]
      - 3: [3, 9, 7, 1]
      - 4: [4, 6, 4]
      - 5: [5, 5]
      - 6: [6, 6]
      - 7: [7, 9, 3, 1]
      - 8: [8, 4, 2, 6]
      - 9: [9, 1]

*** Predict sequence
    #+BEGIN_SRC python :results output :pp :exports both
      def seq0(num):
          return 0

      def seq1(num):
          return 1

      def seq2(num):
          if num > 0:
              s = [2, 4, 8, 6]
              if num < 5:
                  return s[num-1]
              else:
                  return s[num % 4 - 1]
          else:
              return 1

      assert(seq1(22) == 1)
      assert(seq0(100) == 0)
      assert(seq2(2) == 4)
      assert(seq2(4) == 6)
      assert(seq2(5) == 2)
      assert(seq2(10) == 4)
      print('Tests passed')
    #+END_SRC

    #+RESULTS:
    : Tests passed

*** Function generator
    #+BEGIN_SRC  python :results output :pp :exports both
      def first(n):
          return n + 1

      def second(n):
          return n + 2

      def function_generator(k, n):
          list_of_functions = [first(n), second(n)]
          return list_of_functions[k]

      print(function_generator(0, 10))
    #+END_SRC

    #+RESULTS:
    : 11

*** Ties these snippets together
    #+BEGIN_SRC python :results output :pp :exports both
      def seq0(num):
          return 0

      def seq1(num):
          return 1

      def seq2(num):
          if num > 0:
              s = [2, 4, 8, 6]
              if num < 5:
                  return s[num-1]
              else:
                  return s[num % 4 - 1]
          else:
              return 1

      def func_gen(k, n):
          list_of_functions = [seq0(n), seq1(n), seq2(n)]
          return list_of_functions[k]

      assert(func_gen(2, 10) == 4)
      print('It works!')
    #+END_SRC

    #+RESULTS:
    : It works!

*** Further development
    Obvious that =seqN()= for other numbers should be similar.
    Following /DRY/ principle lets take an attempt to cope with it
    and ...

*** Function itself
    #+BEGIN_SRC python :results output :pp :exports both
      def seq0(num):
          return 0

      def seq1(num):
          return 1

      def seq2(num):
          if num > 0:
              s = [2, 4, 8, 6]
              if num < 5:
                  return s[num-1]
              else:
                  return s[num % 4 - 1]
          else:
              return 1

      def last_digit(k, n):
          list_of_functions = [seq0(n), seq1(n), seq2(n)]
          return list_of_functions[k]

      assert(last_digit(2, 10) == 4)
      print('It works!')
      assert(last_digit(2, 11) == 8)
      assert(last_digit(1, 10) == 1)
      print('It works! also')
    #+END_SRC

    #+RESULTS:
    : It works!
    : It works! also

*** Final version
    Seems like all =seqN= functions might be elegantly
    fit into the one.
    #+BEGIN_SRC python :results output :pp :exports both
      def last_digit(num, order):
          if num > 9:
              num = int(str(num)[-1])
          if order > 0:
              s = [[0, 0], [1, 1], [2, 4, 8, 6],
                   [3, 9, 7, 1], [4, 6], [5, 5],
                   [6, 6], [7, 9, 3, 1], [8, 4, 2, 6],
                   [9, 1]][num]
              if order < len(s) + 1:
                  return s[order-1]
              else:
                  return s[order % len(s) - 1]
          else:
              return 1

      assert(last_digit(2, 10) == 4)
      assert(last_digit(12, 10) == 4)
      assert(last_digit(22, 11) == 8)
      assert(last_digit(7, 2) == 9)
      assert(last_digit(27, 2) == 9)
      assert(last_digit(2 ** 200, 2 ** 300) == 6)
    #+END_SRC

    #+RESULTS:

    
*** Clever solution
    #+BEGIN_SRC python :results output :pp :exports both
      def last_digit(n1, n2):
          return pow( n1, n2, 10 )

      assert(last_digit(2 ** 200, 2 ** 300) == 6)
    #+END_SRC


* #3 How many times does it contain?

** Description
   #+BEGIN_QUOTE
   Your task is to return how many times a string
   contains a given character.

   The function takes a string(inputS) as a paremeter
   and a char(charS) which is the character that you
   will have to find and count.

   For example, if you get an input string "Hello world"
   and the character to find is "o", return 2.
   #+END_QUOTE

** Code
   #+BEGIN_SRC python :results output :pp :exports both
     def string_counter(string, char):
         return string.count(char)

     assert(string_counter('Hello World', 'o') == 2)
   #+END_SRC

   #+RESULTS:

* #4 Second Variation on Caesar Cipher

** Description
   #+BEGIN_QUOTE
   Description:

   In this country soldiers are poor but they need a
   certain level of secrecy for their communications so,
   though they do not know Caesar cypher, they reinvent
   it in the following way.

   They use ASCII, without really knowing it, but code
   only letters a-z and A-Z. Other caracters are kept
   such as.

   They change the "rotate" each new message. This
   "rotate" is a prefix for their message once the 
   message is coded. The prefix is built of 2 letters,
   the second one being shifted from the first one by
   the "rotate", the first one is the first letter,
   after being downcased, of the uncoded message.

   For example if the "rotate" is 2, if the first letter
   of the uncoded message is 'J' the prefix should be
   'jl'.

   To lessen risk they cut the coded message and the
   prefix in five pieces since they have only five
   runners and each runner has only one piece.

   If possible the message will be evenly split
   between the five runners; if not possible, parts 1,
   2, 3, 4 will be longer and part 5 shorter.
   The fifth part can have length equal to the other
   ones or shorter. If there are many options of how
   to split, choose the option where the fifth part has
   the longest length, provided that the previous
   conditions are fulfilled. If the last part is the
   empty string don't put this empty string in the
   resulting array.
   
   For example, if the coded message has a length of 17
   the five parts will have lengths of 4, 4, 4, 4, 1.
   The parts 1, 2, 3, 4 are evenly split and the last
   part of length 1 is shorter. If the length is 16 the
   parts will be of lengths 4, 4, 4, 4, 0. Parts 1, 2, 3,
   4 are evenly split and the fifth runner will stay at
   home since his part is the empty string and is not
   kept.

   Could you ease them in programming their coding?

   Example with shift = 1 :

   message : "I should have known that you would have a
   perfect answer for me!!!"
   
   code : => ["ijJ tipvme ibw", "f lopxo uibu z", "pv xpvme ibwf ",
   "b qfsgfdu botx", "fs gps nf!!!"]

   By the way, maybe could you give them a hand to
   decode?
   #+END_QUOTE

** Solution

*** Appropriate view and test suite
    #+BEGIN_SRC  python :results output :pp :exports both
      def encode_str(strng, shift):
          # your code
          pass

      def decode(arr):
          #your code
          pass


      u = "I should have known that you would have a perfect answer for me!!!"
      v = ["ijJ tipvme ibw", "f lopxo uibu z", "pv xpvme ibwf ", "b qfsgfdu botx", "fs gps nf!!!"]
      assert(encode_str(u, 1) == v)

      u = "O CAPTAIN! my Captain! our fearful trip is done;"
      v = ["opP DBQUBJ", "O! nz Dbqu", "bjo! pvs g", "fbsgvm usj", "q jt epof;"]
      assert(encode_str(u, 1) == v)
    #+END_SRC

*** Task set dissection
    - Shift value determiner;
    - Cyclic shift for letters;
    - Cyclic shift for capital letters;
    - Entire message split technique.


*** Gauge the shift value
    #+BEGIN_SRC python :results output :pp :exports both
      def gauge_shift(first_message):
          return ord(first_message[1]) - ord(first_message[0])

      assert(gauge_shift("jk Jack") == 1)
    #+END_SRC
*** Shift letter task
    #+BEGIN_SRC python :results output :pp :exports both
      letters = [chr(i) for i in range(97, 123)] * 2
      cap_letters = [chr(i) for i in range(65, 91)] * 2

      def shift_symbol(symbol, shift):
          if shift > 26:
              shift = shift % 26
          if symbol.isalpha():
              if symbol.isupper():
                  return cap_letters[cap_letters.index(symbol) + shift]
              else:
                  return letters[letters.index(symbol) + shift]
          else:
              return symbol

      assert(shift_symbol('z', 28) == 'b')
      assert(shift_symbol('z', 2) == 'b')
      assert(shift_symbol('a', 1) == 'b')
      assert(shift_symbol('A', 1) == 'B')
      assert(shift_symbol('%', 22) == '%')
      assert(letters[0] == 'a')
      assert(letters[-1] == 'z')
      assert(cap_letters[0] == 'A')
      assert(cap_letters[-1] == 'Z')
    #+END_SRC

* TestSuite
  #+BEGIN_SRC python :results output :tangle tests/test_toy_samples.py :exports code
    import unittest
    from .. toy_tasks import order

    class TestHiddenOrder(unittest.TestCase):

        def test_simple_behaviour(self):
            self.assertEqual(order("is2 Thi1s T4est 3a"),
                             "Thi1s is2 3a T4est")
  #+END_SRC

* TestRunner
   #+BEGIN_SRC sh :results output :exports both
     python -m unittest tests/test_toy_samples.py

   #+END_SRC

   #+RESULTS:
   #+begin_example
   Traceback (most recent call last):
     File "/usr/lib/python3.4/runpy.py", line 170, in _run_module_as_main
       "__main__", mod_spec)
     File "/usr/lib/python3.4/runpy.py", line 85, in _run_code
       exec(code, run_globals)
     File "/usr/lib/python3.4/unittest/__main__.py", line 18, in <module>
       main(module=None)
     File "/usr/lib/python3.4/unittest/main.py", line 92, in __init__
       self.parseArgs(argv)
     File "/usr/lib/python3.4/unittest/main.py", line 139, in parseArgs
       self.createTests()
     File "/usr/lib/python3.4/unittest/main.py", line 146, in createTests
       self.module)
     File "/usr/lib/python3.4/unittest/loader.py", line 146, in loadTestsFromNames
       suites = [self.loadTestsFromName(name, module) for name in names]
     File "/usr/lib/python3.4/unittest/loader.py", line 146, in <listcomp>
       suites = [self.loadTestsFromName(name, module) for name in names]
     File "/usr/lib/python3.4/unittest/loader.py", line 105, in loadTestsFromName
       module = __import__('.'.join(parts_copy))
     File "/usr/local/share/DVCS/org-pub/tests/test_toy_samples.py", line 2, in <module>
       from .. toy_tasks import order
   ValueError: attempted relative import beyond top-level package
#+end_example

