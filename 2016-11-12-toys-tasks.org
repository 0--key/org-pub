#+BEGIN_HTML
---
layout: post
title: Write Python programs
tagline: " by means of Emacs' toolbox"
permalink: /coding/codewars-toy-tasks.html
categories: [literate programming, Python, CodeWars, emacs]
tags: [coding, algorithms]
---
#+END_HTML
#+STARTUP: showall
#+OPTIONS: tags:nil num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t
#+TOC: headlines 2

* #1 Vowels counter
  #+BEGIN_QUOTE
  Return the number (count) of vowels in the given string.
  We will consider a, e, i, o, and u as vowels for this Kata.
  #+END_QUOTE

  #+BEGIN_SRC python :results output
    def getCount(inputStr):
        num_vowels = 0
        # your code here
        for letter in inputStr:
            list_of_vowels = ['a', 'e', 'i', 'o', 'u']
            if letter in list_of_vowels:
                num_vowels += 1
                #print(letter)
                #print(num_vowels)
        return num_vowels

    input_string = 'John the dully boy write this book'

    print getCount(input_string)
    assert(getCount(input_string) == 9)

  #+END_SRC

  #+RESULTS:
  : 9

* #2 Last digit of a large number
  
** Description

   Define a function

   #+BEGIN_SRC python
   def last_digit(n1, n2):
      return   
   #+END_SRC

   #+BEGIN_QUOTE
  that takes in two numbers a and b and returns the last decimal digit of a^b. Note that a and b may be very large!

  For example, the last decimal digit of 9^7 is 9, since 9^7 = 4782969. The last decimal digit of (2^200)^(2^300), which has over 10^92 decimal digits, is 6.

  The inputs to your function will always be non-negative integers.
  Examples

  last_digit(4, 1)                # returns 4
  last_digit(4, 2)                # returns 6
  last_digit(9, 7)                # returns 9
  last_digit(10, 10 ** 10)        # returns 0
  last_digit(2 ** 200, 2 ** 300)  # returns 6

  Remarks
  JavaScript

  Since JavaScript doesn't have native arbitrary large integers, your arguments are going to be strings representing non-negative integers, e.g.

  lastDigit("10", "10000000000");

  The kata is still as hard as the variants for Haskell or Python, don't worry.
   #+END_QUOTE

** Code

*** Visualise the matrix of number's orders
    #+BEGIN_SRC python :results output :pp :exports both
      def simple_array():
       l = []
       for i in range(10):
	l.append([i] + [str(i**j)[-1] for j in range(10)])
       return l

      for i in simple_array():
       print(i)
    #+END_SRC

    #+RESULTS:
    #+begin_example
    [0, '1', '0', '0', '0', '0', '0', '0', '0', '0', '0']
    [1, '1', '1', '1', '1', '1', '1', '1', '1', '1', '1']
    [2, '1', '2', '4', '8', '6', '2', '4', '8', '6', '2']
    [3, '1', '3', '9', '7', '1', '3', '9', '7', '1', '3']
    [4, '1', '4', '6', '4', '6', '4', '6', '4', '6', '4']
    [5, '1', '5', '5', '5', '5', '5', '5', '5', '5', '5']
    [6, '1', '6', '6', '6', '6', '6', '6', '6', '6', '6']
    [7, '1', '7', '9', '3', '1', '7', '9', '3', '1', '7']
    [8, '1', '8', '4', '2', '6', '8', '4', '2', '6', '8']
    [9, '1', '9', '1', '9', '1', '9', '1', '9', '1', '9']
#+end_example

*** Seeking for the sequences
    - Static are 0, 1, 5, 6
      - 0 as an order determiner has deviation from general
	rule
    - Periodic are 2, 3, 4, 7, 8, 9
      - 2: [2, 4, 6, 8]
      - 3: [3, 9, 7, 1]
      - 4: [4, 6, 4]
      - 7: [7, 9, 3, 1]
      - 8: [8, 4, 2, 6]
      - 9: [9, 1]

*** Entire meta-data
    For simplification purposes lets create a full set of rules.
      - 0: [0, 0]
      - 1: [1, 1]
      - 2: [2, 4, 6, 8]
      - 3: [3, 9, 7, 1]
      - 4: [4, 6, 4]
      - 5: [5, 5]
      - 6: [6, 6]
      - 7: [7, 9, 3, 1]
      - 8: [8, 4, 2, 6]
      - 9: [9, 1]

*** Predict sequence
    #+BEGIN_SRC python :results output :pp :exports both
      def seq0(num):
          return 0

      def seq1(num):
          return 1

      def seq2(num):
          if num > 0:
              s = [2, 4, 8, 6]
              if num < 5:
                  return s[num-1]
              else:
                  return s[num % 4 - 1]
          else:
              return 1

      assert(seq1(22) == 1)
      assert(seq0(100) == 0)
      assert(seq2(2) == 4)
      assert(seq2(4) == 6)
      assert(seq2(5) == 2)
      assert(seq2(10) == 4)
      print('Tests passed')
    #+END_SRC

    #+RESULTS:
    : Tests passed

*** Function generator
    #+BEGIN_SRC  python :results output :pp :exports both
      def first(n):
          return n + 1

      def second(n):
          return n + 2

      def function_generator(k, n):
          list_of_functions = [first(n), second(n)]
          return list_of_functions[k]

      print(function_generator(0, 10))
    #+END_SRC

    #+RESULTS:
    : 11

*** Ties these snippets together
    #+BEGIN_SRC python :results output :pp :exports both
      def seq0(num):
          return 0

      def seq1(num):
          return 1

      def seq2(num):
          if num > 0:
              s = [2, 4, 8, 6]
              if num < 5:
                  return s[num-1]
              else:
                  return s[num % 4 - 1]
          else:
              return 1

      def func_gen(k, n):
          list_of_functions = [seq0(n), seq1(n), seq2(n)]
          return list_of_functions[k]

      assert(func_gen(2, 10) == 4)
      print('It works!')
    #+END_SRC

    #+RESULTS:
    : It works!

*** Further development
    Obvious that =seqN()= for other numbers should be similar.
    Following /DRY/ principle lets take an attempt to cope with it
    and ...

*** Function itself
    #+BEGIN_SRC python :results output :pp :exports both
      def seq0(num):
          return 0

      def seq1(num):
          return 1

      def seq2(num):
          if num > 0:
              s = [2, 4, 8, 6]
              if num < 5:
                  return s[num-1]
              else:
                  return s[num % 4 - 1]
          else:
              return 1

      def last_digit(k, n):
          list_of_functions = [seq0(n), seq1(n), seq2(n)]
          return list_of_functions[k]

      assert(last_digit(2, 10) == 4)
      print('It works!')
      assert(last_digit(2, 11) == 8)
      assert(last_digit(1, 10) == 1)
      print('It works! also')
    #+END_SRC

    #+RESULTS:
    : It works!
    : It works! also

*** Final version
    Seems like all =seqN= functions might be elegantly
    fit into the one.
    #+BEGIN_SRC python :results output :pp :exports both
      def last_digit(num, order):
          if num > 9:
              num = int(str(num)[-1])
          if order > 0:
              s = [[0, 0], [1, 1], [2, 4, 8, 6],
                   [3, 9, 7, 1], [4, 6], [5, 5],
                   [6, 6], [7, 9, 3, 1], [8, 4, 2, 6],
                   [9, 1]][num]
              if order < len(s) + 1:
                  return s[order-1]
              else:
                  return s[order % len(s) - 1]
          else:
              return 1

      assert(last_digit(2, 10) == 4)
      assert(last_digit(12, 10) == 4)
      assert(last_digit(22, 11) == 8)
      assert(last_digit(7, 2) == 9)
      assert(last_digit(27, 2) == 9)
      assert(last_digit(2 ** 200, 2 ** 300) == 6)
    #+END_SRC

    #+RESULTS:

    
*** Clever solution
    #+BEGIN_SRC python :results output :pp :exports both
      def last_digit(n1, n2):
          return pow( n1, n2, 10 )

      assert(last_digit(2 ** 200, 2 ** 300) == 6)
    #+END_SRC


* #3 How many times does it contain?

** Description
   #+BEGIN_QUOTE
   Your task is to return how many times a string
   contains a given character.

   The function takes a string(inputS) as a paremeter
   and a char(charS) which is the character that you
   will have to find and count.

   For example, if you get an input string "Hello world"
   and the character to find is "o", return 2.
   #+END_QUOTE

** Code
   #+BEGIN_SRC python :results output :pp :exports both
     def string_counter(string, char):
         return string.count(char)

     assert(string_counter('Hello World', 'o') == 2)
   #+END_SRC

   #+RESULTS:

* #4 Second Variation on Caesar Cipher

** Description
   #+BEGIN_QUOTE
   Description:

   In this country soldiers are poor but they need a
   certain level of secrecy for their communications so,
   though they do not know Caesar cypher, they reinvent
   it in the following way.

   They use ASCII, without really knowing it, but code
   only letters a-z and A-Z. Other caracters are kept
   such as.

   They change the "rotate" each new message. This
   "rotate" is a prefix for their message once the 
   message is coded. The prefix is built of 2 letters,
   the second one being shifted from the first one by
   the "rotate", the first one is the first letter,
   after being downcased, of the uncoded message.

   For example if the "rotate" is 2, if the first letter
   of the uncoded message is 'J' the prefix should be
   'jl'.

   To lessen risk they cut the coded message and the
   prefix in five pieces since they have only five
   runners and each runner has only one piece.

   If possible the message will be evenly split
   between the five runners; if not possible, parts 1,
   2, 3, 4 will be longer and part 5 shorter.
   The fifth part can have length equal to the other
   ones or shorter. If there are many options of how
   to split, choose the option where the fifth part has
   the longest length, provided that the previous
   conditions are fulfilled. If the last part is the
   empty string don't put this empty string in the
   resulting array.
   
   For example, if the coded message has a length of 17
   the five parts will have lengths of 4, 4, 4, 4, 1.
   The parts 1, 2, 3, 4 are evenly split and the last
   part of length 1 is shorter. If the length is 16 the
   parts will be of lengths 4, 4, 4, 4, 0. Parts 1, 2, 3,
   4 are evenly split and the fifth runner will stay at
   home since his part is the empty string and is not
   kept.

   Could you ease them in programming their coding?

   Example with shift = 1 :

   message : "I should have known that you would have a
   perfect answer for me!!!"
   
   code : => ["ijJ tipvme ibw", "f lopxo uibu z", "pv xpvme ibwf ",
   "b qfsgfdu botx", "fs gps nf!!!"]

   By the way, maybe could you give them a hand to
   decode?
   #+END_QUOTE


** Solution

*** Appropriate view and test suite
    #+BEGIN_SRC  python :results output :pp :exports both
      def encode_str(strng, shift):
          # your code
          pass

      def decode(arr):
          #your code
          pass


      u = "I should have known that you would have a perfect answer for me!!!"
      v = ["ijJ tipvme ibw", "f lopxo uibu z", "pv xpvme ibwf ", "b qfsgfdu botx", "fs gps nf!!!"]
      assert(encode_str(u, 1) == v)

      u = "O CAPTAIN! my Captain! our fearful trip is done;"
      v = ["opP DBQUBJ", "O! nz Dbqu", "bjo! pvs g", "fbsgvm usj", "q jt epof;"]
      assert(encode_str(u, 1) == v)
    #+END_SRC

*** Task set dissection
    - Shift value determiner;
    - Cyclic shift for letters;
    - Cyclic shift for capital letters;
    - Entire message split technique.

*** Gauge the shift value
    #+BEGIN_SRC python :results output :pp :exports both
      def gauge_shift(first_message):
          return ord(first_message[1]) - ord(first_message[0])

      assert(gauge_shift("jk Jack") == 1)
    #+END_SRC
*** Shift letter task
    #+BEGIN_SRC python :results output :pp :exports both
      letters = [chr(i) for i in range(97, 123)] * 2
      cap_letters = [chr(i) for i in range(65, 91)] * 2

      def shift_symbol(symbol, shift):
          if shift > 26:
              shift = shift % 26
          if symbol.isalpha():
              if symbol.isupper():
                  return cap_letters[cap_letters.index(symbol) + shift]
              else:
                  return letters[letters.index(symbol) + shift]
          else:
              return symbol

      assert(shift_symbol('z', 28) == 'b')
      assert(shift_symbol('z', 2) == 'b')
      assert(shift_symbol('a', 1) == 'b')
      assert(shift_symbol('A', 1) == 'B')
      assert(shift_symbol('%', 22) == '%')
      assert(letters[0] == 'a')
      assert(letters[-1] == 'z')
      assert(cap_letters[0] == 'A')
      assert(cap_letters[-1] == 'Z')
    #+END_SRC
*** Tie together
    #+BEGIN_SRC python :results output :pp :exports both
      letters = [chr(i) for i in range(97, 123)] * 2
      cap_letters = [chr(i) for i in range(65, 91)] * 2

      def shift_symbol(symbol, shift):
          if shift > 26:
              shift = shift % 26
          if symbol.isalpha():
              if symbol.isupper():
                  return cap_letters[cap_letters.index(symbol) + shift]
              else:
                  return letters[letters.index(symbol) + shift]
          else:
              return symbol


      def encode_str(string, shift):
          result = []
          for letter in string:
              result.append(shift_symbol(letter, shift))
          return ''.join(result)

      def decode(arr):
          #your code
          pass

      assert(encode_str('AaBb #$!', 1) == 'BbCc #$!')
    #+END_SRC

    #+RESULTS:

* #5 Did I Finish my Sudoku?

** Description
   #+BEGIN_QUOTE
   Write a function done_or_not passing a board (list[list_lines]) as
   parameter. If the board is valid return 'Finished!', otherwise return
   'Try again!'

   Sudoku rules:

   Complete the Sudoku puzzle so that each and every row, column, and region
   contains the numbers one through nine only once.

   Rows:

   There are 9 rows in a traditional Sudoku puzzle. Every row must contain
   the numbers 1, 2, 3, 4, 5, 6, 7, 8, and 9. There may not be any duplicate
   numbers in any row. In other words, there can not be any rows that are
   identical.

   In the illustration the numbers 5, 3, 1, and 2 are the "givens". They can
   not be changed. The remaining numbers in black are the numbers that you
   fill in to complete the row.

   Columns:

   There are 9 columns in a traditional Sudoku puzzle. Like the Sudoku rule
   for rows, every column must also contain the numbers 1, 2, 3, 4, 5, 6, 7,
   8, and 9. Again, there may not be any duplicate numbers in any column.
   Each column will be unique as a result.

   In the illustration the numbers 7, 2, and 6 are the "givens". They can not
   be changed. You fill in the remaining numbers as shown in black to complete
   the column.

   Regions

   A region is a 3x3 box like the one shown to the left. There are 9 regions
   in a traditional Sudoku puzzle.

   Like the Sudoku requirements for rows and columns, every region must also
   contain the numbers 1, 2, 3, 4, 5, 6, 7, 8, and 9. Duplicate numbers are
   not permitted in any region. Each region will differ from the other regions.

   In the illustration the numbers 1, 2, and 8 are the "givens". They can not
   be changed. Fill in the remaining numbers as shown in black to complete
   the region.
   #+END_QUOTE

** Solution

*** Appropriate view
    #+BEGIN_SRC python
      def done_or_not(board): #board[i][j]
          # your solution here
          # ..
          # return 'Finished!'
          # ..
          # or return 'Try again!'
    #+END_SRC
*** Test suite
    #+BEGIN_SRC python :session sudoku
      valid = [
          [1, 3, 2, 5, 7, 9, 4, 6, 8],
          [4, 9, 8, 2, 6, 1, 3, 7, 5],
          [7, 5, 6, 3, 8, 4, 2, 1, 9],
          [6, 4, 3, 1, 5, 8, 7, 9, 2],
          [5, 2, 1, 7, 9, 3, 8, 4, 6],
          [9, 8, 7, 4, 2, 6, 5, 3, 1],
          [2, 1, 4, 9, 3, 5, 6, 8, 7],
          [3, 6, 5, 8, 1, 7, 9, 2, 4],
          [8, 7, 9, 6, 4, 2, 1, 5, 3]]
      assert(done_or_not(valid) == 'Finished!')

      corrupted = [
          [1, 3, 2, 5, 7, 9, 4, 6, 8],
          [4, 9, 8, 2, 6, 1, 3, 7, 5],
          [7, 5, 6, 3, 8, 4, 2, 1, 9],
          [6, 4, 3, 1, 5, 8, 7, 9, 2],
          [5, 2, 1, 7, 9, 3, 8, 4, 6],
          [9, 8, 7, 4, 2, 6, 5, 3, 1],
          [2, 1, 4, 9, 3, 5, 6, 8, 7],
          [3, 6, 5, 8, 1, 7, 9, 2, 4],
          [8, 7, 9, 6, 4, 2, 1, 3, 5]]

      assert(done_or_not(corrupted) == 'Try again!');
    #+END_SRC

    #+RESULTS:

*** Common values
    #+BEGIN_SRC python :session sudoku
    gauge = [i for i in range(1, 10)]
    #+END_SRC

    #+RESULTS:

*** Check the nine elements
    #+BEGIN_SRC python :session sudoku :results output
      def check_the_nine(nine):
          if set(nine) == set(gauge):
              return True
          else:
              return False

      assert(check_the_nine([1, 2, 3, 4, 5, 6, 7, 8, 9]) == True)
      assert(check_the_nine([1, 2, 3, 4, 5, 6, 7, 2, 9]) == False)

    #+END_SRC

    #+RESULTS:

*** Compose nine elements

**** Rows
     #+BEGIN_SRC python :results output :session sudoku
       def check_rows(ll):
           for i in ll:
               if check_the_nine(i):
                   continue
               else:
                   return False
           else:
               return True

       assert(check_rows(valid) == True)
       assert(check_rows(corrupted) == True)
     #+END_SRC

     #+RESULTS:

**** Columns
     #+BEGIN_SRC python :results output :session sudoku
       def check_columns(ll):
           for i in range(9):
               nine = []
               for j in ll:
                   nine.append(j[i])
               if not check_the_nine(nine):
                   return False
           return True

       assert(check_columns(valid) == True)
       assert(check_columns(corrupted) == False)
     #+END_SRC

     #+RESULTS:

**** Rectangles 3 X 3
***** Extract these rectangles by its leftmost upper corner
      #+BEGIN_SRC python :results output :session sudoku
        def extract_rectangle(ll, x, y):
            l = []
            for i in range(x, x+3):
                for j in range(y, y+3):
                    l.append(ll[i][j])
            return l

        assert(extract_rectangle(valid, 0, 0) == [1, 3, 2, 4, 9, 8, 7, 5, 6])
        assert(extract_rectangle(valid, 3, 3) == [1, 5, 8, 7, 9, 3, 4, 2, 6])
      #+END_SRC

      #+RESULTS:
      
***** After that lets iterate all corners in this matrix
      #+BEGIN_SRC python :results output :session sudoku
        def define_corners():
            corners = []
            for i in range(0, 9, 3):
                for j in range(0, 9, 3):
                    corners.append([i, j])
            return corners

        print('\n', define_corners())
      #+END_SRC

      #+RESULTS:
      : 
      : ... ... ... ... ... >>> 
      :  [[0, 0], [0, 3], [0, 6], [3, 0], [3, 3], [3, 6], [6, 0], [6, 3], [6, 6]]

**** Final solution
     #+BEGIN_SRC python :results output :session sudoku
       gauge = [i for i in range(1, 10)]

       def check_the_nine(nine):
           if set(nine) == set(gauge):
               return True
           else:
               return False

       def check_rows(ll):
           for i in ll:
               if check_the_nine(i):
                   continue
               else:
                   return False
           else:
               return True

       def check_columns(ll):
           for i in range(9):
               nine = []
               for j in ll:
                   nine.append(j[i])
               if not check_the_nine(nine):
                   return False
           return True

       def extract_rectangle(ll, x, y):
           l = []
           for i in range(x, x+3):
               for j in range(y, y+3):
                   l.append(ll[i][j])
           return l

       def define_corners():
           corners = []
           for i in range(0, 9, 3):
               for j in range(0, 9, 3):
                   corners.append([i, j])
           return corners

       def done_or_not(board):
           result = True
           for i in define_corners():
               if not check_the_nine(extract_rectangle(board, i[0], i[1])):
                   result = False
           if check_columns(board) == False or check_rows(board) == False:
               result = False
           if result:
               return 'Finished!'
           else:
               return 'Try again!'

       assert(done_or_not(valid) == 'Finished!')
       assert(done_or_not(corrupted) == 'Try again!')
     #+END_SRC

     #+RESULTS:



* #6 Vigenère Autokey Cipher Helper

** Description
   #+BEGIN_QUOTE
   The Vigenère cipher is a classic cipher originally developed
   by Italian cryptographer Giovan Battista Bellaso and published
   in 1553. It is named after a later French cryptographer Blaise
   de Vigenère, who had developed a stronger autokey cipher (a
   cipher that incorporates the message of the text into the key).
   In this kata, we're implementing Vigenère's autokey cipher.
  
   The cipher is easy to understand and implement, but survived
   three centuries of attempts to break it, earning it the
   nickname "le chiffre indéchiffrable" or "the indecipherable c
   ipher."
  
   From Wikipedia:
  
   The Vigenère cipher is a method of encrypting alphabetic text
   by using a series of different Caesar ciphers based on the
   letters of a keyword. It is a simple form of polyalphabetic
   substitution.
   (...)
  
   In a Caesar cipher, each letter of the alphabet is shifted
   along some number of places;
  
   for example, in a Caesar cipher of shift 3, A would become D, B
   would become E, Y would become B and so on. The Vigenère c
   ipher consists of several Caesar ciphers in sequence with
   different shift values.
   The shift is derived by applying a Caesar shift to a character
   with the corresponding index of the key in the alphabet.
  
   With the basic Vigenère Cipher, we assume the key is repeated
   for the length of the text, character by character. In this
   kata, the key is only used once, and then replaced by the
   decoded text. Every encoding and decoding is independent
   (still using the same key to begin with). Unlike the Vigenère
   Cipher Helper kata, the key index is only incremented if the
   current letter is in the provided alphabet.
  
   Visual representation (suggested by OverZealous):
  
   message: my secret code i want to secure
   key:     pa ssword myse c retc od eiwant

   Write a class that, when given a key and an alphabet, can be used
   to encode and decode from the cipher.
  
   E.g.
  
   alphabet = 'abcdefghijklmnopqrstuvwxyz'
   key = 'password'
  
   # creates a cipher helper with each letter substituted
   # by the corresponding character in the key
   c = VigenereCipher(key, alphabet)
  
   c.encode('codewars'); # returns 'rovwsoiv'
   c.decode('laxxhsj'); # returns 'waffles'
  
   # returns 'pmsrebxoy rev lvynmylatcwu dkvzyxi bjbsaib'
   c.encode('amazingly few discotheques provide jukeboxes')
  
   # returns 'amazingly few discotheques provide jukeboxes'
   c.decode('pmsrebxoy rev lvynmylatcwu dkvzyxi bjbsaib')
   Any character not in the alphabet should be left alone.
  
   c.encode('CODEWARS') # returns 'CODEWARS'
   #+END_QUOTE
