#+BEGIN_HTML
---
layout: post
title: Write Python programs
tagline: " by means of Emacs' toolbox"
permalink: /coding/codewars-toy-tasks.html
categories: [literate programming, Python, CodeWars, emacs]
tags: [coding, algorithms]
---
#+END_HTML
#+STARTUP: showall
#+OPTIONS: tags:nil num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t
#+TOC: headlines 2

* #1 Vowels counter
  #+BEGIN_QUOTE
  Return the number (count) of vowels in the given string.
  We will consider a, e, i, o, and u as vowels for this Kata.
  #+END_QUOTE

  #+BEGIN_SRC python :results output
    def getCount(inputStr):
        num_vowels = 0
        # your code here
        for letter in inputStr:
            list_of_vowels = ['a', 'e', 'i', 'o', 'u']
            if letter in list_of_vowels:
                num_vowels += 1
                #print(letter)
                #print(num_vowels)
        return num_vowels

    input_string = 'John the dully boy write this book'

    print getCount(input_string)
    assert(getCount(input_string) == 9)

  #+END_SRC

  #+RESULTS:
  : 9

* #2 Last digit of a large number
  
** Description

   Define a function

   #+BEGIN_SRC python
   def last_digit(n1, n2):
      return   
   #+END_SRC

   #+BEGIN_QUOTE
  that takes in two numbers a and b and returns the last decimal digit of a^b. Note that a and b may be very large!

  For example, the last decimal digit of 9^7 is 9, since 9^7 = 4782969. The last decimal digit of (2^200)^(2^300), which has over 10^92 decimal digits, is 6.

  The inputs to your function will always be non-negative integers.
  Examples

  last_digit(4, 1)                # returns 4
  last_digit(4, 2)                # returns 6
  last_digit(9, 7)                # returns 9
  last_digit(10, 10 ** 10)        # returns 0
  last_digit(2 ** 200, 2 ** 300)  # returns 6

  Remarks
  JavaScript

  Since JavaScript doesn't have native arbitrary large integers, your arguments are going to be strings representing non-negative integers, e.g.

  lastDigit("10", "10000000000");

  The kata is still as hard as the variants for Haskell or Python, don't worry.
   #+END_QUOTE

** Code

*** Visualise the matrix of number's orders
    #+BEGIN_SRC python :results output :pp :exports both
      def simple_array():
       l = []
       for i in range(10):
	l.append([i] + [str(i**j)[-1] for j in range(10)])
       return l

      for i in simple_array():
       print(i)
    #+END_SRC

    #+RESULTS:
    #+begin_example
    [0, '1', '0', '0', '0', '0', '0', '0', '0', '0', '0']
    [1, '1', '1', '1', '1', '1', '1', '1', '1', '1', '1']
    [2, '1', '2', '4', '8', '6', '2', '4', '8', '6', '2']
    [3, '1', '3', '9', '7', '1', '3', '9', '7', '1', '3']
    [4, '1', '4', '6', '4', '6', '4', '6', '4', '6', '4']
    [5, '1', '5', '5', '5', '5', '5', '5', '5', '5', '5']
    [6, '1', '6', '6', '6', '6', '6', '6', '6', '6', '6']
    [7, '1', '7', '9', '3', '1', '7', '9', '3', '1', '7']
    [8, '1', '8', '4', '2', '6', '8', '4', '2', '6', '8']
    [9, '1', '9', '1', '9', '1', '9', '1', '9', '1', '9']
#+end_example

*** Seeking for the sequences
    - Static are 0, 1, 5, 6
      - 0 as an order determiner has deviation from general
	rule
    - Periodic are 2, 3, 4, 7, 8, 9
      - 2: [2, 4, 6, 8]
      - 3: [3, 9, 7, 1]
      - 4: [4, 6, 4]
      - 7: [7, 9, 3, 1]
      - 8: [8, 4, 2, 6]
      - 9: [9, 1]

*** Entire meta-data
    For simplification purposes lets create a full set of rules.
      - 0: [0, 0]
      - 1: [1, 1]
      - 2: [2, 4, 6, 8]
      - 3: [3, 9, 7, 1]
      - 4: [4, 6, 4]
      - 5: [5, 5]
      - 6: [6, 6]
      - 7: [7, 9, 3, 1]
      - 8: [8, 4, 2, 6]
      - 9: [9, 1]

*** Predict sequence
    #+BEGIN_SRC python :results output :pp :exports both
      def seq0(num):
          return 0

      def seq1(num):
          return 1

      def seq2(num):
          if num > 0:
              s = [2, 4, 8, 6]
              if num < 5:
                  return s[num-1]
              else:
                  return s[num % 4 - 1]
          else:
              return 1

      assert(seq1(22) == 1)
      assert(seq0(100) == 0)
      assert(seq2(2) == 4)
      assert(seq2(4) == 6)
      assert(seq2(5) == 2)
      assert(seq2(10) == 4)
      print('Tests passed')
    #+END_SRC

    #+RESULTS:
    : Tests passed

*** Function generator
    #+BEGIN_SRC  python :results output :pp :exports both
      def first(n):
          return n + 1

      def second(n):
          return n + 2

      def function_generator(k, n):
          list_of_functions = [first(n), second(n)]
          return list_of_functions[k]

      print(function_generator(0, 10))
    #+END_SRC

    #+RESULTS:
    : 11

*** Ties these snippets together
    #+BEGIN_SRC python :results output :pp :exports both
      def seq0(num):
          return 0

      def seq1(num):
          return 1

      def seq2(num):
          if num > 0:
              s = [2, 4, 8, 6]
              if num < 5:
                  return s[num-1]
              else:
                  return s[num % 4 - 1]
          else:
              return 1

      def func_gen(k, n):
          list_of_functions = [seq0(n), seq1(n), seq2(n)]
          return list_of_functions[k]

      assert(func_gen(2, 10) == 4)
      print('It works!')
    #+END_SRC

    #+RESULTS:
    : It works!

*** Further development
    Obvious that =seqN()= for other numbers should be similar.
    Following /DRY/ principle lets take an attempt to cope with it
    and ...

*** Function itself
    #+BEGIN_SRC python :results output :pp :exports both
      def seq0(num):
          return 0

      def seq1(num):
          return 1

      def seq2(num):
          if num > 0:
              s = [2, 4, 8, 6]
              if num < 5:
                  return s[num-1]
              else:
                  return s[num % 4 - 1]
          else:
              return 1

      def last_digit(k, n):
          list_of_functions = [seq0(n), seq1(n), seq2(n)]
          return list_of_functions[k]

      assert(last_digit(2, 10) == 4)
      print('It works!')
      assert(last_digit(2, 11) == 8)
      assert(last_digit(1, 10) == 1)
      print('It works! also')
    #+END_SRC

    #+RESULTS:
    : It works!
    : It works! also

*** Final version
    Seems like all =seqN= functions might be elegantly
    fit into the one.
    #+BEGIN_SRC python :results output :pp :exports both
      def last_digit(num, order):
          if num > 9:
              num = int(str(num)[-1])
          if order > 0:
              s = [[0, 0], [1, 1], [2, 4, 8, 6],
                   [3, 9, 7, 1], [4, 6], [5, 5],
                   [6, 6], [7, 9, 3, 1], [8, 4, 2, 6],
                   [9, 1]][num]
              if order < len(s) + 1:
                  return s[order-1]
              else:
                  return s[order % len(s) - 1]
          else:
              return 1

      assert(last_digit(2, 10) == 4)
      assert(last_digit(12, 10) == 4)
      assert(last_digit(22, 11) == 8)
      assert(last_digit(7, 2) == 9)
      assert(last_digit(27, 2) == 9)
      assert(last_digit(2 ** 200, 2 ** 300) == 6)
    #+END_SRC

    #+RESULTS:

    
*** Clever solution
    #+BEGIN_SRC python :results output :pp :exports both
      def last_digit(n1, n2):
          return pow( n1, n2, 10 )

      assert(last_digit(2 ** 200, 2 ** 300) == 6)
    #+END_SRC

* #3 How many times does it contain?

** Description
   #+BEGIN_QUOTE
   Your task is to return how many times a string
   contains a given character.

   The function takes a string(inputS) as a paremeter
   and a char(charS) which is the character that you
   will have to find and count.

   For example, if you get an input string "Hello world"
   and the character to find is "o", return 2.
   #+END_QUOTE

** Code
   #+BEGIN_SRC python :results output :pp :exports both
     def string_counter(string, char):
         return string.count(char)

     assert(string_counter('Hello World', 'o') == 2)
   #+END_SRC

   #+RESULTS:

* #4 Second Variation on Caesar Cipher

** Description
   #+BEGIN_QUOTE
   Description:

   In this country soldiers are poor but they need a
   certain level of secrecy for their communications so,
   though they do not know Caesar cypher, they reinvent
   it in the following way.

   They use ASCII, without really knowing it, but code
   only letters a-z and A-Z. Other caracters are kept
   such as.

   They change the "rotate" each new message. This
   "rotate" is a prefix for their message once the 
   message is coded. The prefix is built of 2 letters,
   the second one being shifted from the first one by
   the "rotate", the first one is the first letter,
   after being downcased, of the uncoded message.

   For example if the "rotate" is 2, if the first letter
   of the uncoded message is 'J' the prefix should be
   'jl'.

   To lessen risk they cut the coded message and the
   prefix in five pieces since they have only five
   runners and each runner has only one piece.

   If possible the message will be evenly split
   between the five runners; if not possible, parts 1,
   2, 3, 4 will be longer and part 5 shorter.
   The fifth part can have length equal to the other
   ones or shorter. If there are many options of how
   to split, choose the option where the fifth part has
   the longest length, provided that the previous
   conditions are fulfilled. If the last part is the
   empty string don't put this empty string in the
   resulting array.
   
   For example, if the coded message has a length of 17
   the five parts will have lengths of 4, 4, 4, 4, 1.
   The parts 1, 2, 3, 4 are evenly split and the last
   part of length 1 is shorter. If the length is 16 the
   parts will be of lengths 4, 4, 4, 4, 0. Parts 1, 2, 3,
   4 are evenly split and the fifth runner will stay at
   home since his part is the empty string and is not
   kept.

   Could you ease them in programming their coding?

   Example with shift = 1 :

   message : "I should have known that you would have a
   perfect answer for me!!!"
   
   code : => ["ijJ tipvme ibw", "f lopxo uibu z", "pv xpvme ibwf ",
   "b qfsgfdu botx", "fs gps nf!!!"]

   By the way, maybe could you give them a hand to
   decode?
   #+END_QUOTE


** Solution

*** Appropriate view and test suite
    #+BEGIN_SRC  python :results output :pp :exports both
      def encode_str(strng, shift):
          # your code
          pass

      def decode(arr):
          #your code
          pass


      u = "I should have known that you would have a perfect answer for me!!!"
      v = ["ijJ tipvme ibw", "f lopxo uibu z", "pv xpvme ibwf ", "b qfsgfdu botx", "fs gps nf!!!"]
      assert(encode_str(u, 1) == v)

      u = "O CAPTAIN! my Captain! our fearful trip is done;"
      v = ["opP DBQUBJ", "O! nz Dbqu", "bjo! pvs g", "fbsgvm usj", "q jt epof;"]
      assert(encode_str(u, 1) == v)
    #+END_SRC

*** Task set dissection
    - Shift value determiner;
    - Cyclic shift for letters;
    - Cyclic shift for capital letters;
    - Entire message split technique.

*** Gauge the shift value
    #+BEGIN_SRC python :results output :pp :exports both
      def gauge_shift(first_message):
          return ord(first_message[1]) - ord(first_message[0])

      assert(gauge_shift("jk Jack") == 1)
    #+END_SRC
*** Shift letter task
    #+BEGIN_SRC python :results output :pp :exports both
      letters = [chr(i) for i in range(97, 123)] * 2
      cap_letters = [chr(i) for i in range(65, 91)] * 2

      def shift_symbol(symbol, shift):
          if shift > 26:
              shift = shift % 26
          if symbol.isalpha():
              if symbol.isupper():
                  return cap_letters[cap_letters.index(symbol) + shift]
              else:
                  return letters[letters.index(symbol) + shift]
          else:
              return symbol

      assert(shift_symbol('z', 28) == 'b')
      assert(shift_symbol('z', 2) == 'b')
      assert(shift_symbol('a', 1) == 'b')
      assert(shift_symbol('A', 1) == 'B')
      assert(shift_symbol('%', 22) == '%')
      assert(letters[0] == 'a')
      assert(letters[-1] == 'z')
      assert(cap_letters[0] == 'A')
      assert(cap_letters[-1] == 'Z')
    #+END_SRC
*** Tie together
    #+BEGIN_SRC python :results output :pp :exports both
      letters = [chr(i) for i in range(97, 123)] * 2
      cap_letters = [chr(i) for i in range(65, 91)] * 2

      def shift_symbol(symbol, shift):
          if shift > 26:
              shift = shift % 26
          if symbol.isalpha():
              if symbol.isupper():
                  return cap_letters[cap_letters.index(symbol) + shift]
              else:
                  return letters[letters.index(symbol) + shift]
          else:
              return symbol


      def encode_str(string, shift):
          result = []
          for letter in string:
              result.append(shift_symbol(letter, shift))
          return ''.join(result)

      def decode(arr):
          #your code
          pass

      assert(encode_str('AaBb #$!', 1) == 'BbCc #$!')
    #+END_SRC

    #+RESULTS:

* #5 Did I Finish my Sudoku?

** Description
   #+BEGIN_QUOTE
   Write a function done_or_not passing a board (list[list_lines]) as
   parameter. If the board is valid return 'Finished!', otherwise return
   'Try again!'

   Sudoku rules:

   Complete the Sudoku puzzle so that each and every row, column, and region
   contains the numbers one through nine only once.

   Rows:

   There are 9 rows in a traditional Sudoku puzzle. Every row must contain
   the numbers 1, 2, 3, 4, 5, 6, 7, 8, and 9. There may not be any duplicate
   numbers in any row. In other words, there can not be any rows that are
   identical.

   In the illustration the numbers 5, 3, 1, and 2 are the "givens". They can
   not be changed. The remaining numbers in black are the numbers that you
   fill in to complete the row.

   Columns:

   There are 9 columns in a traditional Sudoku puzzle. Like the Sudoku rule
   for rows, every column must also contain the numbers 1, 2, 3, 4, 5, 6, 7,
   8, and 9. Again, there may not be any duplicate numbers in any column.
   Each column will be unique as a result.

   In the illustration the numbers 7, 2, and 6 are the "givens". They can not
   be changed. You fill in the remaining numbers as shown in black to complete
   the column.

   Regions

   A region is a 3x3 box like the one shown to the left. There are 9 regions
   in a traditional Sudoku puzzle.

   Like the Sudoku requirements for rows and columns, every region must also
   contain the numbers 1, 2, 3, 4, 5, 6, 7, 8, and 9. Duplicate numbers are
   not permitted in any region. Each region will differ from the other regions.

   In the illustration the numbers 1, 2, and 8 are the "givens". They can not
   be changed. Fill in the remaining numbers as shown in black to complete
   the region.
   #+END_QUOTE

** Solution

*** Appropriate view
    #+BEGIN_SRC python
      def done_or_not(board): #board[i][j]
          # your solution here
          # ..
          # return 'Finished!'
          # ..
          # or return 'Try again!'
    #+END_SRC
*** Test suite
    #+BEGIN_SRC python :session sudoku
      valid = [
          [1, 3, 2, 5, 7, 9, 4, 6, 8],
          [4, 9, 8, 2, 6, 1, 3, 7, 5],
          [7, 5, 6, 3, 8, 4, 2, 1, 9],
          [6, 4, 3, 1, 5, 8, 7, 9, 2],
          [5, 2, 1, 7, 9, 3, 8, 4, 6],
          [9, 8, 7, 4, 2, 6, 5, 3, 1],
          [2, 1, 4, 9, 3, 5, 6, 8, 7],
          [3, 6, 5, 8, 1, 7, 9, 2, 4],
          [8, 7, 9, 6, 4, 2, 1, 5, 3]]
      assert(done_or_not(valid) == 'Finished!')

      corrupted = [
          [1, 3, 2, 5, 7, 9, 4, 6, 8],
          [4, 9, 8, 2, 6, 1, 3, 7, 5],
          [7, 5, 6, 3, 8, 4, 2, 1, 9],
          [6, 4, 3, 1, 5, 8, 7, 9, 2],
          [5, 2, 1, 7, 9, 3, 8, 4, 6],
          [9, 8, 7, 4, 2, 6, 5, 3, 1],
          [2, 1, 4, 9, 3, 5, 6, 8, 7],
          [3, 6, 5, 8, 1, 7, 9, 2, 4],
          [8, 7, 9, 6, 4, 2, 1, 3, 5]]

      assert(done_or_not(corrupted) == 'Try again!');
    #+END_SRC

    #+RESULTS:

*** Common values
    #+BEGIN_SRC python :session sudoku
    gauge = [i for i in range(1, 10)]
    #+END_SRC

    #+RESULTS:

*** Check the nine elements
    #+BEGIN_SRC python :session sudoku :results output
      def check_the_nine(nine):
          if set(nine) == set(gauge):
              return True
          else:
              return False

      assert(check_the_nine([1, 2, 3, 4, 5, 6, 7, 8, 9]) == True)
      assert(check_the_nine([1, 2, 3, 4, 5, 6, 7, 2, 9]) == False)

    #+END_SRC

    #+RESULTS:

*** Compose nine elements

**** Rows
     #+BEGIN_SRC python :results output :session sudoku
       def check_rows(ll):
           for i in ll:
               if check_the_nine(i):
                   continue
               else:
                   return False
           else:
               return True

       assert(check_rows(valid) == True)
       assert(check_rows(corrupted) == True)
     #+END_SRC

     #+RESULTS:

**** Columns
     #+BEGIN_SRC python :results output :session sudoku
       def check_columns(ll):
           for i in range(9):
               nine = []
               for j in ll:
                   nine.append(j[i])
               if not check_the_nine(nine):
                   return False
           return True

       assert(check_columns(valid) == True)
       assert(check_columns(corrupted) == False)
     #+END_SRC

     #+RESULTS:

**** Rectangles 3 X 3
***** Extract these rectangles by its leftmost upper corner
      #+BEGIN_SRC python :results output :session sudoku
        def extract_rectangle(ll, x, y):
            l = []
            for i in range(x, x+3):
                for j in range(y, y+3):
                    l.append(ll[i][j])
            return l

        assert(extract_rectangle(valid, 0, 0) == [1, 3, 2, 4, 9, 8, 7, 5, 6])
        assert(extract_rectangle(valid, 3, 3) == [1, 5, 8, 7, 9, 3, 4, 2, 6])
      #+END_SRC

      #+RESULTS:
      
***** After that lets iterate all corners in this matrix
      #+BEGIN_SRC python :results output :session sudoku
        def define_corners():
            corners = []
            for i in range(0, 9, 3):
                for j in range(0, 9, 3):
                    corners.append([i, j])
            return corners

        print('\n', define_corners())
      #+END_SRC

      #+RESULTS:
      : 
      : ... ... ... ... ... >>> 
      :  [[0, 0], [0, 3], [0, 6], [3, 0], [3, 3], [3, 6], [6, 0], [6, 3], [6, 6]]

** Final solution
   #+BEGIN_SRC python :results output :session sudoku
     gauge = [i for i in range(1, 10)]

     def check_the_nine(nine):
         if set(nine) == set(gauge):
             return True
         else:
             return False

     def check_rows(ll):
         for i in ll:
             if check_the_nine(i):
                 continue
             else:
                 return False
         else:
             return True

     def check_columns(ll):
         for i in range(9):
             nine = []
             for j in ll:
                 nine.append(j[i])
             if not check_the_nine(nine):
                 return False
         return True

     def extract_rectangle(ll, x, y):
         l = []
         for i in range(x, x+3):
             for j in range(y, y+3):
                 l.append(ll[i][j])
         return l

     def define_corners():
         corners = []
         for i in range(0, 9, 3):
             for j in range(0, 9, 3):
                 corners.append([i, j])
         return corners

     def done_or_not(board):
         result = True
         for i in define_corners():
             if not check_the_nine(extract_rectangle(board, i[0], i[1])):
                 result = False
         if check_columns(board) == False or check_rows(board) == False:
             result = False
         if result:
             return 'Finished!'
         else:
             return 'Try again!'

     assert(done_or_not(valid) == 'Finished!')
     assert(done_or_not(corrupted) == 'Try again!')
   #+END_SRC

   #+RESULTS:

* #6 Vigenère Autokey Cipher Helper

** Description
   #+BEGIN_QUOTE
   The Vigenère cipher is a classic cipher originally developed
   by Italian cryptographer Giovan Battista Bellaso and published
   in 1553. It is named after a later French cryptographer Blaise
   de Vigenère, who had developed a stronger autokey cipher (a
   cipher that incorporates the message of the text into the key).
   In this kata, we're implementing Vigenère's autokey cipher.
  
   The cipher is easy to understand and implement, but survived
   three centuries of attempts to break it, earning it the
   nickname "le chiffre indéchiffrable" or "the indecipherable c
   ipher."
  
   From Wikipedia:
  
   The Vigenère cipher is a method of encrypting alphabetic text
   by using a series of different Caesar ciphers based on the
   letters of a keyword. It is a simple form of polyalphabetic
   substitution.
   (...)
  
   In a Caesar cipher, each letter of the alphabet is shifted
   along some number of places;
  
   for example, in a Caesar cipher of shift 3, A would become D, B
   would become E, Y would become B and so on. The Vigenère c
   ipher consists of several Caesar ciphers in sequence with
   different shift values.
   The shift is derived by applying a Caesar shift to a character
   with the corresponding index of the key in the alphabet.
  
   With the basic Vigenère Cipher, we assume the key is repeated
   for the length of the text, character by character. In this
   kata, the key is only used once, and then replaced by the
   decoded text. Every encoding and decoding is independent
   (still using the same key to begin with). Unlike the Vigenère
   Cipher Helper kata, the key index is only incremented if the
   current letter is in the provided alphabet.
  
   Visual representation (suggested by OverZealous):
  
   message: my secret code i want to secure
   key:     pa ssword myse c retc od eiwant

   Write a class that, when given a key and an alphabet, can be used
   to encode and decode from the cipher.
  
   E.g.
  
   alphabet = 'abcdefghijklmnopqrstuvwxyz'
   key = 'password'
  
   # creates a cipher helper with each letter substituted
   # by the corresponding character in the key
   c = VigenereCipher(key, alphabet)
  
   c.encode('codewars'); # returns 'rovwsoiv'
   c.decode('laxxhsj'); # returns 'waffles'
  
   # returns 'pmsrebxoy rev lvynmylatcwu dkvzyxi bjbsaib'
   c.encode('amazingly few discotheques provide jukeboxes')
  
   # returns 'amazingly few discotheques provide jukeboxes'
   c.decode('pmsrebxoy rev lvynmylatcwu dkvzyxi bjbsaib')
   Any character not in the alphabet should be left alone.
  
   c.encode('CODEWARS') # returns 'CODEWARS'

   #+END_QUOTE

** Solution

*** Appropriate form
    #+BEGIN_SRC python :results output :session vig
      alphabet = 'abcdefghijklmnopqrstuvwxyz'
      key = 'password'
      class VigenereCipher(object):
          def __init__(self, key, alphabet):
              self.key = key
              self.alphabet = alphabet
          def special_zip(self, message, satellite):
              # shift the lerrer implementation with
              # additional array of values
              pass
          def satellite(self, message):
              # compose a satellite array with shift values
              # for each symbol in the input message
              pass
          def encode(self, message):
              result = self.special_zip(message, self.satellite(message))
              return result
          def decode(self, message):
              return message[::-1]

    #+END_SRC

    #+RESULTS:

*** Test suite
    #+BEGIN_SRC python :results output :session vig
      # creates a cipher helper with each letter substituted
      # by the corresponding character in the key
      c = VigenereCipher(key, alphabet)
      print(c.encode('codewars')) # returns 'rovwsoiv'
      #.decode('laxxhsj' )   returns 'waffles'
      print(c.decode('laxxhsj'))
      # returns 'pmsrebxoy rev lvynmylatcwu dkvzyxi bjbsaib'
      # c.encode('amazingly few discotheques provide jukeboxes')

      # # returns 'amazingly few discotheques provide jukeboxes'
      # c.decode('pmsrebxoy rev lvynmylatcwu dkvzyxi bjbsaib')
      # Any character not in the alphabet should be left alone.

      # c.encode('CODEWARS') # returns 'CODEWARS'

    #+END_SRC

    #+RESULTS:
    : 
    : ... >>> None
    : ... jshxxal

*** Test a particular case with equal lenght pass and message
    #+BEGIN_SRC python :results output :session vig
      alphabet = 'abcdefghijklmnopqrstuvwxyz' * 2
      key = 'password'
      message = 'codewars'
      assert(alphabet[alphabet.index(message[0]) + alphabet.index(key[0])] == 'r')
      assert(alphabet[alphabet.index(message[1]) + alphabet.index(key[1])] == 'o')
      assert(alphabet[alphabet.index(message[2]) + alphabet.index(key[2])] == 'v')
      assert(alphabet[alphabet.index(message[4]) + alphabet.index(key[4])] == 's')
      #assert(encode('codewars') == 'rovwsoiv')
    #+END_SRC

    #+RESULTS:

*** Decoding sample
    #+BEGIN_SRC python :results output :session vig
      cipher = 'laxxhsj'
      rev_alphabet  = alphabet[::-1]
      assert(rev_alphabet[rev_alphabet.index(cipher[0]) + alphabet.index(key[0])] == 'w')
      assert(rev_alphabet[rev_alphabet.index(cipher[1]) + alphabet.index(key[1])] == 'a')
    #+END_SRC

    #+RESULTS:

*** Dynamic shift satellite array
    Lets create the list with len(message) which contains the nunmbers
    corresponding shift value for every single symbol in the message.
    But when some particular symbol isn't in the alphabet, the shift
    is zero and this symbol not changed at all.

* #7 Human readable duration format

** Description
   #+BEGIN_QUOTE
   Your task in order to complete this Kata is to write a function
   which formats a duration, given as a number of seconds, in a
   human-friendly way.

   The function must accept a non-negative integer. If it is zero,
   it just returns "now". Otherwise, the duration is expressed as
   a combination of years, days, hours, minutes and seconds.

   It is much easier to understand with an example:

   format_duration(62)    # returns "1 minute and 2 seconds"
   format_duration(3662)  # returns "1 hour, 1 minute and 2 seconds"

   Note that spaces are important.
   Detailed rules

   The resulting expression is made of components like 4 seconds,
   1 year, etc. In general, a positive integer and one of the valid
   units of time, separated by a space. The unit of time is used in
   plural if the integer is greater than 1.

   The components are separated by a comma and a space (", ").
   Except the last component, which is separated by " and ", just
   like it would be written in English.

   A more significant units of time will occur before than a least
   significant one. Therefore, 1 second and 1 year is not correct,
   but 1 year and 1 second is.

   Different components have different unit of times. So there is
   not repeated units like in 5 seconds and 1 second.

   A component will not appear at all if its value happens to be zero.
   Hence, 1 minute and 0 seconds is not valid, but it should be just
   1 minute.

   A unit of time must be used "as much as possible". It means that the
   function should not return 61 seconds, but 1 minute and 1 second
   instead. Formally, the duration specified by of a component must not
   be greater than any valid more significant unit of time.

   For the purpose of this Kata, a year is 365 days and a day is 24 hours.
   #+END_QUOTE

* #8 Battleship field validator

** Description
   #+BEGIN_QUOTE
   Write a method that takes a field for well-known board game "Battleship"
   as an argument and returns true if it has a valid disposition of ships,
   false otherwise. Argument is guaranteed to be 10*10 two-dimension array.
   Elements in the array are numbers, 0 if the cell is free and 1 if occupied
   by ship.

   Battleship (also Battleships or Sea Battle) is a guessing game for two
   players. Each player has a 10x10 grid containing several "ships" and
   objective is to destroy enemy's forces by targetting individual cells on
   his field. The ship occupies one or more cells in the grid. Size and number
   of ships may differ from version to version. In this kata we will use
   Soviet/Russian version of the game.

   Before the game begins, players set up the board and place the ships 
   accordingly to the following rules:
   - There must be single battleship (size of 4 cells), 2 cruisers (size 3),
     3 destroyers (size 2) and 4 submarines (size 1). Any additional ships
     are not allowed, as well as missing ships.
   - Each ship must be a straight line, except for submarines, which are just
     single cell.
   - The ship cannot overlap or be in contact with any other ship, neither by
     edge nor by corner.
   #+END_QUOTE

** Appropriate solution form
   #+BEGIN_SRC python
     def validateBattlefield(field):
         # write your magic here
         return True

     battleField = [[1, 0, 0, 0, 0, 1, 1, 0, 0, 0],
                    [1, 0, 1, 0, 0, 0, 0, 0, 1, 0],
                    [1, 0, 1, 0, 1, 1, 1, 0, 1, 0],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
                    [0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
                    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

     Test.assert_equals(validateBattlefield(battleField), True, "Yep! Seems alright", "Nope, something is wrong!");
   #+END_SRC

* #9 Instant Runoff Voting

** Description
   #+BEGIN_QUOTE
   Your task is to implement a function that calculates an
   election winner from a list of voter selections using an
   Instant Runoff Voting algorithm. If you haven't heard of
   IRV, here's a basic overview (slightly altered for this kata):

   - Each voter selects several candidates in order of preference.

   - The votes are tallied from the each voter's first choice.

   - If the first-place candidate has more than half the total votes, they win.

   - Otherwise, find the candidate who got the least votes and remove
     them from each person's voting list.

   - In case of a tie for least, remove all of the tying candidates.

   - In case of a complete tie between every candidate, return
     nil(Ruby)/None(Python)/undefined(JS).

   Start over.
   Continue until somebody has more than half the votes; they are the winner.

   Your function will be given a list of voter ballots; each ballot will be a
   list of candidates (symbols) in descending order of preference. You should
   return the symbol corresponding to the winning candidate. See the default
   test for an example!
   #+END_QUOTE

** Appropriate solution format
   #+BEGIN_SRC python :results output :session runoff :exports both
     def first_place_leader_check(bulletins):
         leaders = [i[0] for i in bulletins]
         if len(set(leaders)) <= len(bulletins) // 2 + 1:
             # leader(s) exist(s) already
             return True
         else:
             # no leader there
             return False

     def count_each_candidate(bulletins):
         # join list of lists together:
         all_candidates = [j for i in bulletins for j in i]
         candidates = set(all_candidates)
         counter = {}
         for i in candidates:
             counter[i] = all_candidates.count(i)
         return counter

     def runoff(voters):
         pass

     voters = [["dem", "ind", "rep"],
               ["rep", "ind", "dem"],
               ["ind", "dem", "rep"],
               ["ind", "rep", "dem"]]

     assert(count_each_candidate(voters) == {"dem": 4, "ind": 4, "rep": 4})
     assert(first_place_leader_check(voters) == True)
     # Test.assert_equals(runoff(voters), "ind")

     voters = [["a", "c", "d", "e", "b"],
               ["e", "b", "d", "c", "a"],
               ["d", "e", "c", "a", "b"],
               ["c", "e", "d", "b", "a"],
               ["b", "e", "a", "c", "d"]];
     # Test.assert_equals(runoff(voters), None);
     assert(first_place_leader_check(voters) == False)
   #+END_SRC

   #+RESULTS:

* #10 Base64 Numeric Translator
  
** Description
   #+BEGIN_QUOTE
   Our standard numbering system is (Base 10). That includes 0
   through 9. Binary is (Base 2), only 1’s and 0’s. And
   Hexadecimal is (Base 16) (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B,
   C, D, E, F). A hexadecimal “F” has a (Base 10) value of 15.
   (Base 64) has 64 individual characters which translate in value
   in (Base 10) from between 0 to 63.
   Write a method that will convert a string from (Base 64) to
   it's (Base 10) integer value.

   The (Base 64) characters from least to greatest will be

   ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/

   Where 'A' is equal to 0 and '/' is equal to 63.

   Just as in standard (Base 10) when you get to the highest
   individual integer 9 the next number adds an additional place and
   starts at the beginning 10; so also (Base 64) when you get to the
   63rd digit '/' and the next number adds an additional place and
   starts at the beginning "BA".

   Example:
   
   base64_to_base10("/") # => 63
   base64_to_base10("BA") # => 64
   base64_to_base10("BB") # => 65
   base64_to_base10("BC") # => 66
   
   Write a method base64_to_base10 that will take a string (Base 64)
   number and output it's (Base 10) value as an integer.
   #+END_QUOTE

** Appropriate solution format
   #+BEGIN_SRC python
     def converter(order, symbol):
         s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
         number = s.index(symbol)
         return number * 64 ** order

     def base64_to_base10(str):
         sigma = 0
         for order, symbol in enumerate(str[::-1]):
             sigma += converter(order, symbol)
         return sigma

     assert(converter(0, 'A') == 0)
     assert(converter(1, 'B') == 64)
     assert(base64_to_base10("A") == 0)
     assert(base64_to_base10("/") == 63)
     assert(base64_to_base10("BA") == 64)
     assert(base64_to_base10("//") == 4095)
     assert(base64_to_base10("WIN") == 90637)
   #+END_SRC

   #+RESULTS:
   : None

** General considerations
   For any /positional/ numeric system with base b:
   xyz = x*b**2 + y*b**1 + z*b**0

* #11 Elementary Arithmetic - Carries Count

** Description
   #+BEGIN_QUOTE
   In elementary arithmetic a "carry" is a digit that is transferred
   from one column of digits to another column of more significant
   digits during a calculation algorithm.

   This Kata is about determining the number of carries performed
   during the addition of multi-digit numbers.
   
   You will receive an input string containing a set of pairs of
   numbers formatted as follows:
   
   123 456
   555 555
   123 594
   
   And your output should be a string formatted as follows:
   
   No carry operation
   3 carry operations
   1 carry operations
   
   Some Assumptions
   
   - Assume that numbers can be of any length.
   - But both numbers in the pair will be of the same length.
   - Although not all the numbers in the set need to be of the same length.
   - If a number is shorter, it will be zero-padded.
   - The input may contain any arbitrary number of pairs.
   #+END_QUOTE

** Appropriate solution format
   #+BEGIN_SRC python :results output
     def solve(input_string):
             #your code here

     Test.assert_equals(solve("123 456\n555 555\n123 594"), "No carry operation\n3 carry operations\n1 carry operations", "Try this one: (123 - 456 | 555 - 555 | 123 - 594)")
     Test.assert_equals(solve("321 679\n098 805\n123 867"), "3 carry operations\n2 carry operations\n1 carry operations", "Try this one: (321 - 679 | 098 - 805 | 123 - 867)")
     Test.assert_equals(solve("123 457\n631 372\n999 111"), "1 carry operations\n2 carry operations\n3 carry operations", "Try this one: (123 - 457 | 631 - 372 | 999 - 111)")
     Test.assert_equals(solve("123 457\n123 456\n654 312\n999 000\n123 457"), "1 carry operations\nNo carry operation\nNo carry operation\nNo carry operation\n1 carry operations","Try this one: (123 - 457 | 123 - 456 | 654 - 312 | 999 - 000 | 123 - 457)")
     Test.assert_equals(solve("1 9\n123456789 111111101\n01 09\n11 09\n123 457"), "1 carry operations\n1 carry operations\n1 carry operations\n1 carry operations\n1 carry operations", "Try this one: (1 - 9 | 123456789 - 111111101 | 01 - 09 | 11 - 09 | 123 - 457)")
   #+END_SRC

* #12 Valid Parentheses
  
** Description
   #+BEGIN_QUOTE
   Write a function called validParentheses that takes a string of parentheses,
   and determines if the order of the parentheses is valid. validParentheses
   should return true if the string is valid, and false if it's invalid.

   Examples:
   validParentheses( "()" ) => returns true
   validParentheses( ")(()))" ) => returns false
   validParentheses( "(" ) => returns false
   validParentheses( "(())((()())())" ) => returns true

   All input strings will be nonempty, and will only consist of open parentheses '(' and/or closed parentheses ')'
   #+END_QUOTE

** Appropriate solution format
   #+BEGIN_SRC python :results output
     def extract_parentheses(string):
         if string:
             return [i for i in string if i in '[]{}()']
         else:
             return False

     def pair(parentheses):
         if parentheses == ')':
             return '('
         elif parentheses == ']':
             return '['
         elif parentheses == '}':
             return '{'
         else:
             return False

     def valid_parentheses(string):
         if string == "":
             return True
         else:
             opening = []
             closing = []
             parentheses = extract_parentheses(string)
             if parentheses and len(parentheses) % 2 == 0:
                 for i in parentheses:
                     if not pair(i):
                         opening.append(i)
                         print("this is an opening sequence: ", opening)
                     else:
                         if opening[-1] == i:
                             # annihilate them both
                             opening.pop()
                         else:
                             print("The closing parentheses mismatch")
                             return False
                 if opening == [] and closing == []:
                     return True
                 else:
                     print('Mismatch in parentheses order')
                     return False
             else:
                 return False

     print(valid_parentheses("hi())("))
     assert(extract_parentheses(")test") == [')'])
     assert(pair(')') == '(')
     assert(valid_parentheses("  (") == False)
     assert(valid_parentheses(")test") == False)
     assert(valid_parentheses("") == True)
     assert(valid_parentheses("()()") == True)
     assert(valid_parentheses("hi())(") == False)
     assert(valid_parentheses("hi(hi)()") == True)
   #+END_SRC

   #+RESULTS:

* #13 Coordinates Validator
  
** Description
   #+BEGIN_QUOTE
   You need to create a function that will validate if given parameters
   are valid geographical coordinates.

   Valid coordinates look like the following: "23.32353342, -32.543534534".
   The return value should be either true or false.

   Latitude (which is first float) can be between 0 and 90, positive or
   negative. Longitude (which is second float) can be between 0 and 180,
   positive or negative.

   Coordinates can only contain digits, or one of the following symbols
   (including space after comma) -, .

   There should be no space between the minus "-" sign and the digit after
   it.
   #+END_QUOTE
** Appropriate solution
   #+BEGIN_SRC python :results output
     def is_valid_coordinates(coordinates):
         if 'e' not in coordinates and\
            'E' not in coordinates:
             try:
                 lat, lon = map(float, coordinates.split(','))
             except:
                 return False
         else:
             return False
         print(lat, lon)
         if lat < -90 or lat > 90:
             return False
         if lon < -180 or lon > 180:
             return False
         return True

     valid_coordinates = [
         "-23, 25",
         "4, -3",
         "24.53525235, 23.45235",
         "04, -23.234235",
         "43.91343345, 143"]

     for coordinate in valid_coordinates:
         assert is_valid_coordinates(coordinate) == True,\
             "%s validation failed." % coordinate

     invalid_coordinates = [
         "23.234, - 23.4234",
         "2342.43536, 34.324236",
         "N23.43345, E32.6457",
         "99.234, 12.324",
         "6.325624, 43.34345.345",
         "0, 1,2",
         "0.342q0832, 1.2324",
         "23.245, 1e1"]

     for coordinate in invalid_coordinates:
         assert is_valid_coordinates(coordinate) == False,\
             "%s validation failed." % coordinate
   #+END_SRC
* #14 Pete, the baker
** Description
   #+BEGIN_QUOTE
   Pete likes to bake some cakes. He has some recipes and ingredients.
   Unfortunately he is not good in maths. Can you help him to find out,
   how many cakes he could bake considering his recipes?

   Write a function cakes(), which takes the recipe (object) and the available ingredients (also an object) and returns the maximum number of cakes Pete can bake (integer). For simplicity there are no units for the amounts (e.g. 1 lb of flour or 200 g of sugar are simply 1 or 200). Ingredients that are not present in the objects, can be considered as 0.

   Examples:

   # must return 2
   cakes({flour: 500, sugar: 200, eggs: 1},
   {flour: 1200, sugar: 1200, eggs: 5, milk: 200})
   # must return 0
   cakes({apples: 3, flour: 300, sugar: 150, milk: 100, oil: 100},
   {sugar: 500, flour: 2000, milk: 2000})
   #+END_QUOTE
** Solution
   #+BEGIN_SRC python :results output
     def cakes(recipe, available):
         # TODO: insert code


     # test.describe('Testing Pete, the Baker')
     # test.it('gives us the right number of cakes')

     recipe = {"flour": 500, "sugar": 200, "eggs": 1}
     available = {"flour": 1200, "sugar": 1200, "eggs": 5, "milk": 200}
     # test.assert_equals(cakes(recipe, available), 2, 'Wrong result for example #1')
     assert(cakes(recipe, available) == 2)

     recipe = {"apples": 3, "flour": 300, "sugar": 150, "milk": 100, "oil": 100}
     available = {"sugar": 500, "flour": 2000, "milk": 2000}
     # test.assert_equals(cakes(recipe, available), 0, 'Wrong result for example #2')
     assert(cakes(recipe, available) == 0)
   #+END_SRC
* # Decode the Morse code
** Description
   #+BEGIN_QUOTE
   In this kata you have to write a simple Morse code decoder. While
   the Morse code is now mostly superceded by voice and digital data
   communication channels, it still has its use in some applications
   around the world.

   The Morse code encodes every character as a sequence of "dots" and
   "dashes". For example, the letter A is coded as ·−, letter Q is coded
   as −−·−, and digit 1 is coded as ·−−−. The Morse code is
   case-insensitive, traditionally capital letters are used. When the
   message is written in Morse code, a single space is used to separate
   the character codes and 3 spaces are used to separate words. For
   example, the message HEY JUDE in Morse code is
   ···· · −·−− ·−−− ··− −·· ·.

   NOTE: Extra spaces before or after the code have no meaning and
   should be ignored.

   In addition to letters, digits and some punctuation, there are some
   special service codes, the most notorious of those is the international
   distress signal SOS (that was first issued by Titanic), that is coded
   as ···−−−···. These special codes are treated as single special
   characters, and usually are transmitted as separate words.

   Your task is to implement a function decodeMorse(morseCode), that would
   take the morse code as input and return a decoded human-readable string.

   For example:

   decodeMorse('.... . -.--   .--- ..- -.. .')
   #should return "HEY JUDE"

   The Morse code table is preloaded for you as a dictionary, feel free to
   use it. In CoffeeScript, C++, JavaScript, PHP, Python, Ruby and TypeScript,
   the table can be accessed like this: MORSE_CODE['.--'], in Java it is
   MorseCode.get('.--'), in C# it is MorseCode.Get('.--'), in Haskell the
   codes are in a Map String String and can be accessed like this:
   morseCodes ! ".--".

   All the test strings would contain valid Morse code, so you may skip
   checking for errors and exceptions. In C#, tests will fail if the solution
   code throws an exception, please keep that in mind. This is mostly because
   otherwise the engine would simply ignore the tests, resulting in a "valid"
   solution.

   Good luck!
   #+END_QUOTE
** Solution
   #+BEGIN_SRC python :results output
     def decodeMorse(morseCode):
         return morseCode.replace('.', MORSE_CODE['.']).replace('-', MORSE_CODE['-']).replace(' ', '')


     def testAndPrint(got, expected):
         if got == expected:
             test.expect(True)
         else:
             print "<pre style='display:inline'>Got '%s', expected '%s'</pre>" % (got, expected)
             test.expect(False)

     test.describe("Example from description")
     testAndPrint(decodeMorse('.... . -.--   .--- ..- -.. .'), 'HEY JUDE')

     test.describe("Your own tests")
     # Add more tests here
   #+END_SRC
** Best practice
   #+BEGIN_SRC python
     def decodeMorse(morseCode):
         return ' '.join(''.join(MORSE_CODE[letter] for letter in word.split(' ')) for word in morseCode.strip().split('   '))
   #+END_SRC
* Next bigger number with the same digits
** Description
   #+BEGIN_QUOTE
   You have to create a function that takes a positive integer number
   and returns the next bigger number formed by the same digits:

   next_bigger(12)==21
   next_bigger(513)==531
   next_bigger(2017)==2071
   If no bigger number can be composed using those digits, return -1:

   next_bigger(9)==-1
   next_bigger(111)==-1
   next_bigger(531)==-1
   #+END_QUOTE
** Solution
   #+BEGIN_SRC python
     def next_bigger(n):
      #your code here

     Test.assert_equals(next_bigger(12),21)
     Test.assert_equals(next_bigger(513),531)
     Test.assert_equals(next_bigger(2017),2071)
     Test.assert_equals(next_bigger(414),441)
     Test.assert_equals(next_bigger(144),414)
   #+END_SRC
* Simple fraction to mixed number converter
** Description
   #+BEGIN_QUOTE
   Given a string representing a simple fraction x/y, your function must return a string
   representing the corresponding mixed fraction in the following format:

   a b/c

   where a is integer part and b/c is irreducible proper fraction. There must be exactly
   one space between a and b/c.

   If the x/y equals the integer part, return integer part only. If integer part is zero,
   return the irreducible proper fraction only. In both of these cases, the resulting string
   must not contain any spaces.

   Division by zero should raise an error (preferably, the standard zero division error of
   your language).

   Examples

   Input: 42/9, expected result: 4 2/3.
   Input: 6/3, expedted result: 2.
   Input: 4/6, expected result: 2/3.
   Input: 0/18891, expected result: 0.
   Input: -10/7, expected result: -1 3/7.
   Inputs 0/0 or 3/0 must raise a zero division error.
   Note

   Make sure not to modify the input of your function in-place, it is a bad practice.
   #+END_QUOTE
** Solution
   #+BEGIN_SRC python :results output
     def gcd(a, b):
         while(b):
             a, b = b, a % b
         return a

     def simplify(n, d):
         g = gcd(n, d)
         if g > 1:
             return str(n//g) + '/' + str(d//g)
         else:
             return str(n) + '/' + str(d)

     def mixed_fraction(s):
         n, d = map(int, s.split('/'))
         if n != 0:
             if d != 0:
                 if abs(n) < d:
                     return simplify(n, d)
                 else:
                     # for positive argiments olny!
                     integer_part = n // d
                     ratio = n % d # * integer_part
                     if ratio:
                         return str(integer_part) + ' ' + simplify(ratio, d)
                     else:
                         return str(integer_part)
             else:
                 1 / 0
         else:
             return '0'

     print(mixed_fraction('-10/7'))
     print(mixed_fraction('-22/-7'))
     assert(simplify(8, 12) == '2/3')
     assert(simplify(-8, 12) == '-2/3')
     assert(gcd(2, 3) == 1)
     assert(gcd(14, 21) == 7)
     assert(gcd(-14, 21) == 7)
     assert(gcd(12, 144) == 12)
     assert(mixed_fraction('42/9') == '4 2/3')
     assert(mixed_fraction('6/3') == '2')
     assert(mixed_fraction('4/6') == '2/3')
     assert(mixed_fraction('0/18891') == '0')
     # assert(mixed_fraction('-10/7') == '-1 3/7')
     # Test.assert_equals(mixed_fraction('-22/-7'), '3 1/7')
     # Test.expect_error("Must raise ZeroDivisionError", lambda: mixed_fraction(0, 0))
     # Test.expect_error("Must raise ZeroDivisionError", lambda: mixed_fraction(3, 0))
   #+END_SRC

   #+RESULTS:
   : -2 4/7
* Common denominator
** Description
   #+BEGIN_QUOTE
    You will have a list of rationals in the form

    [ [numer_1, denom_1] , ... [numer_n, denom_n] ]

    where all numbers are positive ints.

    You have to produce a result in the form

    [ [N_1, D] ... [N_n, D] ]

    in which D is as small as possible and

    N_1/D == numer_1/denom_1 ... N_n/D == numer_n,/denom_n.

    Example:

    convertFracs [(1, 2), (1, 3), (1, 4)] `shouldBe` [(6, 12), (4, 12), (3, 12)]
   #+END_QUOTE
