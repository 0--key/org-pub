#+BEGIN_EXPORT html
---
layout: post
title: Dissecting Python
tagline: " inside out"
permalink: /python/books/disecting_python.html
categories: [Python Dissection]
tags: [book, template]
---
#+END_EXPORT

#+STARTUP: showall
#+OPTIONS: tags:nil num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t
#+TOC: headlines 2
#+PROPERTY:header-args :results output :exports both :eval no-export

* Gestation                                                        :noexport:

** TODO Primary material gathering;

*** TODO Snippets
    - Docs about testing;
    - Docs about working with source code in Babel;

*** TODO Thoughts

**** Thesis and antithesis
     Thesis – a statement or theory that is put forward as a premise
     to be maintained or. proved. Antithesis – the negation or
     contradiction of the thesis. Synthesis – the resolution of the
     conflict between thesis and antithesis.
**** Retrospecive analysis

     - Coding in a modern sense of it was born in 40s. It was
       something in the middle of lore and mistery;
     - The idea of /compiler/ as a middleware between humans and
       machines was on the tip of the tongue but implemented by Grace
       Hopper titanic efforts and phenomenal persistence only a decade
       later;
     - The bedrock for /high-level/ programming languages;
     - Unit-testing as a /separate approach/ in programming was
       introduced in 90s;

**** Cognition inertia
**** Appollo 11 computer

     Verb --> noun approach

**** __main__ in their footer

     as a sign of uncompetence - run a =Python= program in your
     terminal doesn't seem a good idea. At all. 

     Why computer programming is a such tough task for humans? There
     are several plain predicatives to deem that is just overthinked.

**** 5 basic concepts of any programming language:

     - Variables;
     - Data structures;
     - Control structures;
     - Syntax;
     - Tools;

**** Major paradigms of programming:

     - Imperative;
     - Logical;
     - Functional;
     - Object-oriented;

       

     So, at the first glance all these concepts seem clear, dense and
     terse.

**** Wrong approach in studying

     Let's make a brisk glance on the history of programming
     languages. In the most cases it would shade the light on
     question: “How does it ever happen?”

     It is not secret that coding and computing by electronic
     macnihens is a relatevely fossil lore for humans. I suppose it
     was 1940s as an early begining. It was a straightforward coding
     due to absence of high-level programming languages.


     In 1950s Grace Hopper achived success and implement on practive
     her idea of compilation human-written programs into
     machine-readable set of precise instructions. The gestation of
     high-level programming languges started since.
     
     The plehora of new and modern human-readable hight-level
     programming languages was announced in 1970s due to widely
     spreaded idea to write programs as a human-friendly text and
     compile it later into the source code (mostly unreadable by
     humans) executable by machines at least.
     
**** Separate folder with tests

     It will serve as an essence of studying material and later, I
     hope, as an yeast for your further usage as a backbone for Python
     development. Just pull my repository and launch the set of tests
     on your local environment.

      As I can imagine it would be something
      ==/0--key/0-py/tests/blackbox/

      - Innate constants (True, False, None)
      - Operators:
	- Assignment
	- Comparison (==, <, >, != etc.)

    
**** Python actual version

     There are two =Python= branches and the youngest one will serve us
     as a subject of our deductive dissection. Dow you heard about
     ~Black Box https://www.guru99.com/black-box-testing.html~ approach
     in study? Yes, it is so old by the nature, and innovative nowadays
     in software testing only. Not in learning practice once again due
     the stunt prejudice about the age of practicioqneer.
    
**** DONE False Footnotes with new words meaning

     Inappropriate veiw and feel.

**** DONE Align img in bootstrap

*** DONE Quotes

    - "Programs must be written for people to read, and only incidentally  
     for machines to execute."

     Abelson & Sussman, SICP, preface to the first edition

    - "Short words are best and the old words when short are best of all."

      Winston Churchill

    - “The glass is neither half empty nor half full. It’s simply
      larger than it needs to be.”

      Grace Hopper

    - “Manage things. Lead people.”

      Grace Hopper

*** Books

    - "Learning Python" & "Python Pocket Reference" by Mark Lutz
    - 

** Indexing as an ordered sequence

*** DONE Dedication

*** TODO Preface

    Main incentives
    Major aim for writing
    Minor target
    Satellite achievements
    Average readers audience

** Wrapping and extension.


* Dedication

  #+BEGIN_QUOTE
  For my tiny family
  #+END_QUOTE


* Relevant quotes
    #+BEGIN_QUOTE
    Programs must be written for people to read, and only incidentally
    for machines to execute."

   - *Abelson & Sussman, SICP, preface to the first edition*
   #+END_QUOTE

   -----
   #+BEGIN_QUOTE
    "Short words are best and the old words when short are best of
      all."

   - *Winston Churchill*
   #+END_QUOTE

   -----

    #+BEGIN_QUOTE
    “The glass is neither half empty nor half full. It’s simply larger
      than it needs to be.”

   - *Grace Hopper*
   #+END_QUOTE

   -----

   #+BEGIN_QUOTE
    “Manage things. Lead people.”

   - *Grace Hopper*
   #+END_QUOTE

   -----


* Preface

  #+CAPTION: Older tutor
  #+ATTR_HTML: :class rounded float-center :alt Play as test
  #+ATTR_HTML: :title Conduct an experiment
  https://mk0tredebmaru2va759a.kinstacdn.com/wp-content/uploads/2018/09/best-blocks-for-toddlers.jpg

  This book is about programming machines to do precisely what humans
  ordered them. It is same in intention /like/ a thousand similar
  books already written about the same subject. And it is a completely
  wrong /first/ impression.

  It is a fiction book in a wide sense of this word: it has an
  objective, the subjects and the plot. The principal objective in
  this book is Python and its usage by humans.

  The subjects are students, teachers, books, programmers, software
  engineers, other professionals related to programming. And the plot
  is a misleading: its history, the current state of things with
  focus on software industry.

  Followed by a set of plain deductions it might unlock for a literate
  reader a =kingdom of programming=. It is a =kingdom= definitely due
  to the strict set of inner rules controlled by /his Majesty/
  *Python3*. Learning these rules one by one is the only decent path
  to succeed in studying a /system/.

  There is only one path: a bit straightforward, but narrow approach
  to get rid the *misleading phenomenon* off once and forever in our
  lives. Yes it /is/ neither simple nor popular, alas. It's a natural
  treatment for learning in general, boys and girls.

  All what I might propose to you is to serve as a bit experienced and
  older guide on your way to acquire precious knowledge. And it will
  be a small nudge in the right direction. Nothing more, nothing less.

  Keep tighter, please.


** For boring reader

   The task isn't so tough it might seem, the most rules are naturally
   entangled. There are a handful of /primal/ ones. The rest are
   derivatives /based on/ the primal.

   Undoubtedly it simplifies the lesson. All what you need is to build
   the knowledge tree-like structure in your mind. There are only a
   /thriple/ primals: =True=, =False= and = None =. All other are
   knots in the large net of derivatives.
   
   For density this is a bottom paragraph with no data. The tap in a
   barrel.



** Style Notes

   A killer feature of this book is its /style/: it is *not* yet
   another user manual, journal or TTY input/output spiced with
   comments. It might deem a bit strange though. What if the book will
   be written in =programming language=? Initially you will wittingly
   immerse in a full-dressed Python code, the true, valid code, I
   mean. The paramount of clarity and density. It might expected that
   soon the =reader= will being capable to gaze its incredible power
   and naked beauty from inside.

   The main intention of this book is to take to the reader a chance to
   be fun at the reading. At the another hand it might be impossible to
   write a giddy novel for human readers and an absolutely precise set
   of instructions for computer at the same time. Bear it in mind ~the
   text~ deliberately splitted into two main chunks by its purpose:
   /the comments/ and /the source code/ itself. Comments are for humans
   only, but the source code is for two sides of software industry: it is
   human-readable and machine-executable simultaneously.


** The side effect


   The side effect might be a cramming gap during learning. All
   material compounded into a monolith by a logical intersection. Thus
   it is highly welcomed to follow the /sequence of chapters/ by its
   nature, from first and foremost to the second one, the third etc.

   A multiplied repetition in hope to rehearse the chunk of studied
   material and forget it forever — short, attractive but lousy way to
   achieve knowledge. It is a _cognition trap_. It is an eloquent
   illustration of redundant, tedious and, in same time, *popular way
   to do things wrong*.

   All what you are need in is to delve into Python depths leading by
   an experience guide. That's it.

   All articles are short enough to being grasped _less than 25
   minutes_. Self-pace is highly welcomed: /going forward only after
   you know the current point as a back of your hand/. No need to
   subdue yourself to read down and down without any comprehension. It
   is not a learning at all, it is a foolish torture. /Slow your pace,
   please./ You couldn't catch ~all at once~.

   A minuscule free time in the early morning /before/ yours breakfast
   would be an ideal time for learning /programming/. It is not a joke,
   guys, moving forward.

   
* General observations:


** Debugging is a major time-consuming task



   #+CAPTION: Time and efforts for debug
   #+ATTR_HTML: :class rounded float-center :alt Typical proportion
   #+ATTR_HTML: :title The lion share of efforts
   https://i1.wp.com/semiengineering.com/wp-content/uploads/2019/02/debug1.png



   for a casual software developer and often it consumes up to 40% of
   their efforts to develop and maintain software nowadays.


** Cognitive dissonance and size of manuals

   #+CAPTION: The average manual for proficiency
   #+ATTR_HTML: :class rounded float-center :alt The Art
   #+ATTR_HTML: :title They are enormous
   https://cdn-blog.adafruit.com/uploads/2018/12/1Capture.jpg

   There are tons of material and most of it represents ~programming
   language~ in an imperative style.


** An average age of readers

   #+CAPTION: The team
   #+ATTR_HTML: :class rounded float-center :alt Unexperience of youth
   #+ATTR_HTML: :title They are so young
   https://peerbits-wpengine.netdna-ssl.com/wp-content/uploads/2020/03/improve-software-development-team-main.jpg


   
** Testing as an innate tool to learn for humans;

   - Testing in CS is a comparatively young concept;

   #+CAPTION: Toddlers
   #+ATTR_HTML: :class rounded float-center :alt Play as test
   #+ATTR_HTML: :title Conduct an experiment
   https://mk0tredebmaru2va759a.kinstacdn.com/wp-content/uploads/2018/09/best-blocks-for-toddlers.jpg


** Einstellung effect;
   in writing book about programming

   #+CAPTION: Brain fog
   #+ATTR_HTML: :class rounded float-center :alt True thinking is a tough task
   #+ATTR_HTML: :title The large set of cognitive biases
   https://miro.medium.com/max/3600/1*dxkkOejSHnx7FVfj5vo5jg.jpeg



** Reading as a tourture 

   Avoidance of source code reading (escapism);


* A harsh deduction

  #+CAPTION: Test failure
  #+ATTR_HTML: :class rounded float-left :alt Animals also test
  #+ATTR_HTML: :title Unconscious testing
  http://0--key.github.io/assets/img/pydes/monkey.jpeg]]

  Summarize the handful of penetraiting observations above it might be
  dedused:

  The paramount goals of writing are absolute clarity and density, so
  it might sound a quite strange. In reality, it is much complex task
  than it seems and a plethora of already written manuals about
  programming is a strict evidence to interpret this as a _spoiled
  approach_. In contrary: “Why men avoid reading and study some common
  things as programming in just one book? Is it /really/ so boring?”

  My grandma told me “Eugene Onegin” in just three evenings. She knew
  each string in the poem's sequence(!) It was so astounding and 40
  years later I still remember it. Not the poem itself! The
  remembrance of no-limit boundaries for human mind. Now I'm can
  conclude that only natural language is enough complex and
  complicated to transmit such long message for a such long time.

  30 years ago, in 1991 I became a programmer. My tool was a quite
  advanced micro-calculator programmed manually in a
  pseudo-hexadecimal directives. It was incredibly precise, fast as a
  blizzard and it definitely were games there! “The fly of a
  bumblebee” named one.

  Further where were many programming languages studied by the manual
  testing, and in 2016 I push my head in to the wall. After sufficient
  time any piece of my programs became unreadable and seem so knotty
  like some aliens do it by his left toe. The same observation is True
  for programs written not by me. What the crap is going on!

  “Why we spawn such degenerative programs?”: I asked myself and seeking
  for clue 4 years in deep contemplation.

  And now I definitely know why it is so ugly with writing programs
  now. Not a secret at all. The clue to this puzzle is the nature of
  humans, a large set of caveats in their cognitive thinking:

  - =Do anything and anytime like others do=

    If all you know about did something successfully, all what you
    need to do is to mimic them. In other words it is ~heard style~.

  - =If it is so old - it is True by the age=

    A misconseption from our young childhood. Based on ~All adults are
    genious because they're old.~

  - =You can't change it as you like=

    Naturally if a man following his prejudices a long time anough to
    do nothing at all in the shame to do something wrong. ~Yes, he just
    can't do it. Period.~
  

  Unconsciously people do things in a some particular way
  and it seems a queer mistake. It is not common to find your reactive
  behavior as your own error looking backward.

  Why you can't ask yourself: “Why it is so difficult to read any book
  about programming?” Easy and habitual way to take it as granted. But
  for me it is a usual challenge. Maybe I am personally excessively
  curious and persistent to digging up to core of matter. And I have
  to say something about programming.

  Programming is easy by its nature and overcomplicated by the men. It is
  just something wrong with approach to study it.

  As you might notice casual programming handbook often dismantle
  programming wrong.

  Absolutely wrong. It uses English as a stem language, and

  programming language itself dissected by large set of
  _pseudo-tests_ -

  Even if any book can't be pretentious, this one doesn't. It is
  exactly the essence out of learning how to program machines to
  execute yours and only yours orders in a most effective way of
  studying: by sequentially, from the elementary ones to most complex,
  testing its features.
	  

** Several acid notations


** Defining predicatives intentionally

 It's naturally to draw the boundaries around your invention. It's
 neither a silver bullet nor panacea for learners. Cognition demands a
 lot of time for reading and digesting each chapter. Nothing
 misterious.


*** Why Python

*** Why pure Python

*** Already existing solutions overview


** Thurther deduction

   - Conversion a boring manual into a fiction book;
   - Black (Pandorra) Box approach;
   - Programming languages genealogy:
     + Atavisms:
       + 72 char per string;
   - Codex as a phenomena disclosure;
   - Related material allocation on two pages at once;
   - Pomodoro technique realization;


* Testing as a nodal ology tool

  #+CAPTION: An infant conducting test
  #+ATTR_HTML: :alt An infant :title Infant building a tower
  [[http://0--key.github.io/assets/img/pydes/infant-building-a-tower.jpeg]]

  If you're observed an infant behavior strictly enough you might
  notice that it is /a silent (they can't talk yet) testing how things
  work/. With brisk ingenuity baby implements the series of conscious
  acts and it should be interpreted as experiments to examine the
  nature of events. Bear in mind its inborn origin, because every
  child do it absolutely autonomous, we got conclusion about a native
  and natural compatibility of humans and testing approach for study.


* Several useful tips and tricks

** Two pages on the screen

** Git and clone it

** Contribute


* A dumb testing set (test the test itself)                        :noexport:

   #+BEGIN_SRC python :noweb yes :tangle tests/test_00dumb_testing.py
     <<module-level-docstring>>


     <<import-header>>


     <<none-false-true-assertion>>


     <<none-false-true-comparison-assertion>>
   #+END_SRC


* Testing Python built-in fundamental constants

  The bedrock of testing a programming language.


** The set of attributes required


*** The top
    #+NAME: module-level-docstring
    #+BEGIN_SRC python :session test
      # -*- coding: utf-8 -*-
      """A module-level docstring

      Notice the comment above the docstring specifying the encoding.
      Docstrings do appear in the bytecode, so you can access this through
      the ``__doc__`` attribute. This is also what you'll see if you call
      help() on a module or any other Python object.

      It might be unnecessary in our case, when we write a simplified
      version of programs. If the aim is a paragon of clarity it should
      contain all required attributes of clarity and further support.

      You might notice that /coding definition/ on the first string, the
      second string begins with tripled double quotes and a sentence there.
      They are the obligatory attributes if you have intention to do things
      as it should do.

      """
     #+END_SRC


*** The import

     #+NAME: import-header
     #+BEGIN_SRC python :session test
       import unittest

       """By its purpose all programming languages should allow the reader to
       understand what exactly this particular text do in a much explicit
       manner. The real state of things requires a literate reader with a huge
       experience exactly in reading programs and comprehension. Noticeable
       that nowadays most programs demand from reader such proficiency that
       it made them truly readable for the handful of true geeks only.

       Nevertheless, this fact usually omitted by specialists, who spent a
       huge amount of time reading so overcomplicated texts of programs.
       Through time, it became a normal if anybody can't grasp an idea out
       from program's source code on the fly.

       “It is just lack of experience!”: they say usually. You might object
       by notation that several professionals can't catch the essence out
       from that text because it poorly written, they answer something like:
       “It works well enough to be scrutinized much more precisely.”

       Nowadays it is deemed as normal to lack capability to understand
       source code even for professionals. Naturally it is abnormal.

       """
     #+END_SRC

     #+RESULTS: import-header


*** None-False-True existence assertion


     #+NAME: none-false-true-assertion
     #+BEGIN_SRC python :session test
       class TestLanguageBase(unittest.TestCase):  # <-- class definition
           """begins this reserved word /class/ following by the /name of class/
           and its /parent class/ in the brackets. On first steps it might be
           like a magic mantra to enter the /test suite/.

           The first and foremost taks for testing is to ensure how testing
           tools work. In our case lets begit from the simplest things ever -
           lets discover built-in constants True, False, None with already
           defining testing methods one by one.

           | Method                    | Checks that          |
           |---------------------------+----------------------+
           | assertEqual(a, b)         | a == b               |
           | assertNotEqual(a, b)      | a != b               |
           | assertTrue(x)             | bool(x) is True      |
           | assertFalse(x)            | bool(x) is False     |
           | assertIs(a, b)            | a is b               |
           | assertIsNot(a, b)         | a is not b           |
           | assertIsNone(x)           | x is None            |
           | assertIsNotNone(x)        | x is not None        |
           | assertIn(a, b)            | a in b               |
           | assertNotIn(a, b)         | a not in b           |
           | assertIsInstance(a, b)    | isinstance(a, b)     |
           | assertNotIsInstance(a, b) | not isinstance(a, b) |

           """

           def test_does_true_ever_exist(self):  # <-- an atomic test case itself
               # and the sample of in-line comment
               # self-explanatory name of the test case to focus attention
               self.assertTrue(True)  # <-- straight assertion
               # True really exists.
               # if this test do pass with success.

           def test_does_false_ever_exist(self):  # No comments
               self.assertFalse(False)  # False also exists

           def test_does_none_ever_exist(self):  # no comments
               self.assertIsNone(None)  # None also predefined by the language

           """ Now it became obious that three built-in constants are well-defined
           out of the box.  It is very time to compare them against each other.
           """

           def test_none_fasle_true_comparison(self):
               self.assertIsNotNone(True)  # Naturally, neiver False
               self.assertIsNotNone(False)  # nor True are not None
               self.assertFalse(None)  # !! None has a Boolean False
               #
               self.assertIs(True, True)  #
               self.assertIs(False, False)  #
               self.assertIs(None, None)  #
               #
               self.assertNotEqual(False, True)  #
               self.assertNotEqual(True, None)  #
               self.assertNotEqual(False, None)  #
               #
               self.assertIsNotNone(False)  #
               self.assertIsNotNone(True)  #


       """
       | Method                    | Checks that          |
       |---------------------------+----------------------+
       | assertEqual(a, b)         | a == b               |
       | assertNotEqual(a, b)      | a != b               |
       | assertTrue(x)             | bool(x) is True      |
       | assertFalse(x)            | bool(x) is False     |
       | assertIs(a, b)            | a is b               |
       | assertIsNot(a, b)         | a is not b           |
       | assertIsNone(x)           | x is None            |
       | assertIsNotNone(x)        | x is not None        |
       | assertIn(a, b)            | a in b               |
       | assertNotIn(a, b)         | a not in b           |
       | assertIsInstance(a, b)    | isinstance(a, b)     |
       | assertNotIsInstance(a, b) | not isinstance(a, b) |

       Now we definitely check up several methods of assertion embedded into
       Python unittest module, and ensure that three fundamental constants
       are also accessible out from the box.

       The four methods at the bottom of the table:

        - assertIn(a, b)
        - assertNotIn(a, b)
        - assertIsInstance(a, b)
        - assertNotIsInstance(a, b)

       are unnecessary right now because their purpose is testing of
       sequencies and instances wich will be introduced a bit later.

       In the next chapter new and principal concepts will be introduced.

       """
     #+END_SRC

     #+RESULTS: true-assertion


** Code elaboration

   #+NAME: full-fledged-sample
   #+BEGIN_SRC python :noweb yes :tangle tests/test_01false_true_none_existence.py :session one
     # -*- coding: utf-8 -*-
     """Now it is the moment to distill your knowledge about writing
     =unittests= in ~Python~. Our previous work in
     =tests/test_00dumb_testing.py= spare too much place in case if you're
     grasp the core idea. Exactly:

        - Module comments;
        - Import section;
        - Test class definition;
        - Set of test cases

     are necesseties to be clear when you're in writing ~Python~ code. Lets
     create a much dense test suite out from existing one and put it in a
     new file =tests/test_01false_true_none_existence.py=

     """

     import unittest

     """The initial Python test suite

     Asserts the existence True, False and None in Python
     """


     class TestFundamentalConstantsExistence(unittest.TestCase):

         """Put all the existence tests together"""

         def test_the_existence(self):
             self.assertTrue(True)  # <-- straight assertion
             self.assertFalse(False)  # False also exists
             self.assertIsNone(None)  # None also predefined by the language


     """Naturally that it is more convenient to tame a dense and terse code
     blocks which are well-fitted on a single page. Thus, try to split all
     your tests into /logical/ blocks for clarity purpose."""
   #+END_SRC

   #+NAME: full-fledged-sample-comparison
   #+BEGIN_SRC python :noweb yes :tangle tests/test_02false_true_none_comparison.py :session second
     # -*- coding: utf-8 -*-
     """Only code to compare None, True and False"""

     import unittest


     class TestCompareFundamentals(unittest.TestCase):

         def test_none_fasle_true_comparison(self):
             self.assertIsNotNone(True)  # Naturally, neiver False
             self.assertIsNotNone(False)  # nor True are not None
             self.assertFalse(None)  # !! None has a Boolean False
             #
             self.assertIs(True, True)  #
             self.assertIs(False, False)  #
             self.assertIs(None, None)  #
             #
             self.assertNotEqual(False, True)  #
             self.assertNotEqual(True, None)  #
             self.assertNotEqual(False, None)  #
             #
             self.assertIsNotNone(False)  #
             self.assertIsNotNone(True)  #


     """Seems it is much elegant than before, but less self-explanatory"""
   #+END_SRC
   
** Further exploration

** Zero, One and a Symbol


*** Assertion and assignment
*** True, False, None, == and = comparison, != and Not

*** Boolean operations

*** Arithmetics


*** None-False-True comparison


     #+NAME: none-false-true-comparison-assertion
     #+BEGIN_SRC python :session test
       class TestCompareFundamentals(unittest.TestCase):

           """Now, when we ensure in existence of None, False and Ture constants,
           it is very time to compare them with its own derivatives as zero
           (0), one (1), the letter('A')

           """

           def test_does_zero_really_boolean_false(self):
               self.assertFalse(0)  #
     #+END_SRC

     #+RESULTS: false-assertion



* Innate datatypes testing


* Enter the Function


* Enter the Object
