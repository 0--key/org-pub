#+BEGIN_EXPORT html
---
layout: page
title: Dissecting Python
tagline: " inside out"
permalink: /python/books/dissecting_python.html
categories: [Python Dissection]
tags: [book, template]
---
#+END_EXPORT

#+STARTUP: showall
#+OPTIONS: tags:nil num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t
#+TOC: headlines 2
#+PROPERTY:header-args :results output :exports both :eval no-export

* Gestation                                                        :noexport:

** TODO Primary material gathering;

*** TODO Snippets
    - Docs about testing;
    - Docs about working with source code in Babel;

*** TODO Thoughts

**** Thesis and antithesis
     Thesis – a statement or theory that is put forward as a premise
     to be maintained or. proved. Antithesis – the negation or
     contradiction of the thesis. Synthesis – the resolution of the
     conflict between thesis and antithesis.
***** separate this facts and weigh them against one another

***** a customary way of doing smth

***** the paramount is a gleefully studying anything 

***** naturally someone noticed that it is a bit effusive

***** this hunch was proved to being correct 

***** a downright wrong conclusion

***** it is not a sham, of course

***** a customary for human cognition self-deception

***** it is so odd and manic in its persistence

***** “Never Mistake Motion for Action” — Ernest Hemingway

***** The source code should be diligently swathed

      with the comments exactly to simplify comprehension by the humans

***** Lets check up the provenance of this particular misleading

***** It is not an author's hobbyhorse of course

***** It is not an aimless writing
      it is an attempt to satisfy your ego

***** Such is the quandary I found myself in.

***** It might deem as a murky and uncertain

***** And most of them are tempted to be professional ASAP

***** It almost sounds like a joke, but I am in dead earnest

***** A nutty things had happened

***** Undoubtly it is a sapid point of view

***** They are so young and spineless

***** Someone who is well versed in the intricacies of this vocation

***** Propensity to make a quick, simple and wrong conclusion out of genuine evidence

***** All they are crammed in a stiff circumstances

      and usually bragging about their true grit in material in several days

***** For the time being, after much dithering back and forth, I dubbed my
      little brainchild DPIO

***** The intention was to bestow a mould for further grouth
      for the youngsters eager to curb this lore

***** Make a toot, joy and gaiety from such boring task as learning

***** All these din around a humble profession as programmer

***** This inference is not rigged or intentionally perverted
      it is just 

***** An attempt to nip this faulty practice
      when the first working sample of code deem as the true one

***** The meaningful way to study programming

***** This is because we as humans
      get bogged down in the means and forget about the end.

***** One of the major steps along the road to creating a remarkable career 

***** The problem, though, is that it painted the wrong picture

***** Intentionally immersed into a valid Python code from a start

***** Usually they are fiddling with StackOverflow, copy and paste

***** Naturally it is a sort of tucking

***** And for their mutual astonishment it just not working!

***** Any ateempt to mull it over fails

***** Brievity and clearness in the same time

***** Confederacy of dunces

***** The root of the matter bound with a human nature:
      everybody habitually deem about yourself in a positive

***** On a helicopter view it seems as a misbegotten attitude to your job

***** And if it works umpteen times consequently it seems to them
      as a proper way without feeling a little twinge

***** Provides you an opportunity to kick your mind into full gear

***** As the practice shows, this is a big smelly sack of baloney

***** But such pat descriptions do not lead to any understanding
      or prevent the same patterns from recurring.

***** What if we could truly fathom why people suddenly behave irrationally

***** With tha awarness we would able to gain better control of what we do

***** To defend a belief or keep affirming that it's true

***** what you contend is what you hope to convince others is correct

***** They are too wordy to be plain and in most cases just intimidatingly perplexing

***** We can ascribe many of these observations to our cognition inertia -
      inability to see things in its genuine nature.

***** It is a brutally realistic appraisal of current state in the industry

***** I still think this is an eminently important difference

***** All they seems to me wierd brainteasers designed to test my analytic mettle

***** A slew of smugs whom incessantly bragging their true grit in comprehension material

***** An ascendency of out-of-date approaches

***** It is not a brash endeavor to pivot all industry upsidedown

***** It was more like some kind of instinctual herd behavior,
      programmed into me

***** Those who defy the odds are especially gritty

***** Grit bore absolutely no relationship to comprehension
      in material

***** And customarily they have no urge and time to ponder
      the irony of the situation

***** Let go of your tendency to make snap judgments

***** We elicit the concequences of this tacit agreement

***** Learn programming in its arcane notation by testing its facets

***** The biggest impediment to your
      success and realizing your potential is not lack of
      productivity, hard work, or intelligence; it is the way in which
      we pursue it

***** By clinging to the old formula for studying we are leaving enormous
      amounts of potential untapped

***** Step by step they muddle themselves in flamboyant definitions
      and wierd concepts

***** The lesser of two evils
      
***** Even a perfunctury analysis shows a plethora caveats in these judgements

***** 
**** Competitors

**** Retrospecive analysis

     - Coding in a modern sense of it was born in 40s. It was
       something in the middle of lore and mistery;
     - The idea of /compiler/ as a middleware between humans and
       machines was on the tip of the tongue but implemented by Grace
       Hopper titanic efforts and phenomenal persistence only a decade
       later;
     - The bedrock for /high-level/ programming languages;
     - Unit-testing as a /separate approach/ in programming was
       introduced in 90s;

**** Cognition inertia
**** Appollo 11 computer

     Verb --> noun approach

**** __main__ in their footer

     as a sign of uncompetence - run a =Python= program in your
     terminal doesn't seem a good idea. At all. 

     Why computer programming is a such tough task for humans? There
     are several plain predicatives to deem that is just overthinked.

**** 5 basic concepts of any programming language:

     - Variables;
     - Data structures;
     - Control structures;
     - Syntax;
     - Tools;

**** Major paradigms of programming:

     - Imperative;
     - Logical;
     - Functional;
     - Object-oriented;

       

     So, at the first glance all these concepts seem clear, dense and
     terse.

**** Wrong approach in studying

     Let's make a brisk glance on the history of programming
     languages. In the most cases it would shade the light on
     question: “How does it ever happen?”

     It is not secret that coding and computing by electronic
     macnihens is a relatevely fossil lore for humans. I suppose it
     was 1940s as an early begining. It was a straightforward coding
     due to absence of high-level programming languages.


     In 1950s Grace Hopper achived success and implement on practive
     her idea of compilation human-written programs into
     machine-readable set of precise instructions. The gestation of
     high-level programming languges started since.
     
     The plehora of new and modern human-readable hight-level
     programming languages was announced in 1970s due to widely
     spreaded idea to write programs as a human-friendly text and
     compile it later into the source code (mostly unreadable by
     humans) executable by machines at least.
     
**** DONE Children testing building cubes

     An experienced and older guide, the nudge in a right side.

**** DONE Initial Python code simplification

     It will serve as an essence of studying material and later, I
     hope, as an yeast for your further usage as a backbone for Python
     development. Just pull my repository and launch the set of tests
     on your local environment.

      As I can imagine it would be something
      ==/0--key/0-py/tests/blackbox/

      - Innate constants (True, False, None)
      - Operators:
	- Assignment
	- Comparison (==, <, >, != etc.)

    
**** Python actual version

     There are two =Python= branches and the youngest one will serve us
     as a subject of our deductive dissection. Dow you heard about
     ~Black Box https://www.guru99.com/black-box-testing.html~ approach
     in study? Yes, it is so old by the nature, and innovative nowadays
     in software testing only. Not in learning practice once again due
     the stunt prejudice about the age of practicioqneer.
    
**** DONE False Footnotes with new words meaning

     Inappropriate veiw and feel.

**** DONE Align img in bootstrap

*** DONE Quotes

    - "Programs must be written for people to read, and only incidentally  
     for machines to execute."

     Abelson & Sussman, SICP, preface to the first edition

    - "Short words are best and the old words when short are best of all."

      Winston Churchill

    - “The glass is neither half empty nor half full. It’s simply
      larger than it needs to be.”

      Grace Hopper

    - “Manage things. Lead people.”

      Grace Hopper

*** Books

    - "Learning Python" & "Python Pocket Reference" by Mark Lutz
    - 

** Indexing as an ordered sequence

*** DONE Dedication

*** TODO Preface

    Main incentives
    Major aim for writing
    Minor target
    Satellite achievements
    Average readers audience

** Wrapping and extension.


* Dedication

  #+BEGIN_QUOTE
  For my tiny family
  #+END_QUOTE


* Relevant quotes

     #+BEGIN_QUOTE
    “I can calculate the motion of heavenly bodies but not the madness
    of people.”

   - *Isaac Newton*
   #+END_QUOTE
   -----
    #+BEGIN_QUOTE
    Programs must be written for people to read, and only incidentally
    for machines to execute."

   - *Abelson & Sussman, SICP, preface to the first edition*
   #+END_QUOTE
   -----
   #+BEGIN_QUOTE
    "Short words are best and the old words when short are best of
      all."

   - *Winston Churchill*
   #+END_QUOTE
   -----
    #+BEGIN_QUOTE
    “The glass is neither half empty nor half full. It’s simply larger
     than it needs to be.”

   - *Grace Hopper*
   #+END_QUOTE
   -----
   #+BEGIN_QUOTE
    “Manage things. Lead people.”

   - *Grace Hopper*
   #+END_QUOTE
   -----


* Preface

  #+CAPTION: An older tutor
  #+ATTR_HTML: :class rounded float-center :alt A game is a test
  #+ATTR_HTML: :title Conduct an experiment together
  http://0--key.github.io/assets/img/pydes/experienced_tutor.jpeg

  This book is about programming machines to do precisely what humans
  ordered them. It is same in intention /like/ a slew similar books
  already written about the same subject. And it is a completely wrong
  /first/ impression.

  It is a fiction book in a wide sense of this word: it has an
  objective, the subjects and the plot. The principal objective in
  this book is Python and its usage by humans.

  The subjects are students, teachers, books, programmers, software
  engineers and developers, other professionals related to
  programming. The plot is a /misleading/: its prerequisites, its
  past and present in software industry.

  Followed by a set of plain deductions it might unlock for a literate
  reader a =realm of programming=. It is a =realm= actually due to the
  strict set of certain rules defined by /his Majesty/ *Python3*.
  Learning these rules one by one is the only proper way to succeed in
  studying programming language as a /system/.

  There is only one path: a bit straightforward, but narrow approach
  to get rid the *misleading phenomenon* off once and forever in our
  lives. Yes it /is/ neither simple nor popular, alas. It's a natural
  treatment for learning in general, boys and girls.

  All what I might propose to you is to serve as a bit experienced and
  older guide on your way to acquire precious knowledge. And it will
  be a small nudge in the right direction. Nothing more, nothing less.

  Keep tighter, please.


** For boring reader

   The task isn't so tough it might seem, the most rules are naturally
   entangled. There are a handful of /primal/ ones. The rest are
   /derivatives/ based on the primal.

   Undoubtedly it simplifies the lesson. All what you need is to build
   the knowledge tree-like structure in your mind. There are only a
   /thriple/ primals: =True=, =False= and =None=. All other are
   derivatives based on them.
   
   For density this is a bottom paragraph with no data. The tap in a
   barrel.



** Style Notes

   A killer feature of this book is its /style/: it is *not* yet
   another user manual, journal or TTY input/output spiced with
   comments. It might deem a bit strange though. What if the book will
   be written in =programming language=? Initially you will wittingly
   immerse in a full-dressed Python code, the true, valid code, I
   mean. The paramount of clarity and density. It might expected that
   soon the =reader= will being capable to gaze its incredible power
   and naked beauty from inside.

   The main intention of this book is to take to the reader a chance to
   be fun at the reading. At the another hand it might be impossible to
   write a giddy novel for human readers and an absolutely precise set
   of instructions for computer at the same time. Bear it in mind ~the
   text~ deliberately splitted into two main chunks by its purpose:
   /the comments/ and /the source code/ itself. Comments are for humans
   only, but the source code is for two sides of software industry: it is
   human-readable and machine-executable simultaneously.


** The side effect


   The side effect might be a cramming gap during learning. All
   material compounded into a monolith by a logical intersection. Thus
   it is highly welcomed to follow the /sequence of chapters/ by its
   nature, from first and foremost to the second one, the third etc.

   A multiplied repetition in hope to rehearse the chunk of studied
   material verbatim and forget it forever — short, attractive but
   lousy way to achieve knowledge. It is a _cognition trap_. And yes,
   it is a dogged determination in self-deception. It is an eloquent
   illustration of redundant, tedious and, in same time, *popular way
   to do things wrong*.

   All what you are need in is to delve into Python depths leading by
   an experience guide. That's it.

   All articles are short enough to being grasped _less than 25
   minutes_. Self-pace is highly welcomed: /going forward only after
   you sure that know the present point as a back of your hand/. No
   need to subdue yourself to read down and down without any
   comprehension. It is not a learning at all, it is a foolish
   torture. /Slow your pace, please./ You can't fathom it ~all of a
   sudden~.

   A minuscule free time in the early morning /before/ yours breakfast
   would be an ideal time for learning /programming/. It is not a joke,
   guys, moving forward.

   
* General observations:


** Debugging is a major time-consuming task



   #+CAPTION: Time and efforts for debug
   #+ATTR_HTML: :class rounded float-center :alt Typical proportion
   #+ATTR_HTML: :title The lion share of efforts
   http://0--key.github.io/assets/img/pydes/debugging.jpg



   for a casual software developer and often it consumes up to 40% of
   their efforts to develop and maintain software nowadays.


** Cognitive dissonance and size of manuals

   #+CAPTION: The average manual for proficiency
   #+ATTR_HTML: :class rounded float-center :alt The Art
   #+ATTR_HTML: :title They are enormous
   http://0--key.github.io/assets/img/pydes/the_volumes.jpeg

   At one hand we have a /relatively simple/ job: to tame a machine to
   execute the precise sequence of operations utilizing the
   /programming language/ clear enough to be understood by humans and
   machines. At another hand we might notice a plethora of manuals,
   tutorials and intimidatingly large books which take an attempt to
   dismantle the programming as a professional skill using a plain
   English commonly and a handful of real code snippets as an
   unavoidable exclusion out of this rule.


** A hidden complexity

   It is straightly inherent to a human nature. Even an experienced
   /professional/ software developer often can't explain what the
   machine should do even in a plain English. Misleading in human
   language should spawn only erroneous decidions with the following
   often wrong conclusions. The slogan "Keep clear" is a paramount
   goal of most humans, it is difficult to detour the /brain fog/
   after the some time spent in mulling around something enough tough.

   

   There are tons of material and most of it represents ~programming
   language~ in an imperative style.


** An average age of readers

   #+CAPTION: The team
   #+ATTR_HTML: :class rounded float-center :alt Unexperience of youth
   #+ATTR_HTML: :title They are so young
   http://0--key.github.io/assets/img/pydes/software-development-team.jpeg


   
** Testing as an innate tool to learn for humans;

   #+BEGIN_QUOTE
    “There are no facts, only interpretations.”

   - *Friedrich Nietzsche*
   #+END_QUOTE

   -----

   #+CAPTION: Toddlers playing
   #+ATTR_HTML: :class rounded float-center :alt A play as a test
   #+ATTR_HTML: :title Conduct an experiment
   http://0--key.github.io/assets/img/pydes/experienced_tutor.jpeg

   If I ask you what you see on the picture above your average answer
   would be: “There are two small boys playing cubes together.” Right?
   But what if I tell you: “These two boys are conducting a series of
   test to cognate the hidden features of cubes. The older one
   demonstrating his knowledge in this particular area, and the
   youngest one assisting him and /learning by testing/.”

   This is a simple and straight evidence of human innate ability to
   learn. And it requires no words at all, just attention, patience and
   perseverance to deduce the meaning of this show. 


** Unit testing in CS

   It was initially introduced by computer scientists in 80s, and
   became a wide-spread and popular concept in the industry only in
   the beginning of 21st century. Thus, it is easy to deduce that
   initially almost all modern programming languages, which was
   developed earlier this date, was happily built without any unit
   testing at all.

   Yes, it was. 


** Einstellung effect or golden hammer

   #+BEGIN_QUOTE
    “If the only tool you have is a hammer, one tends to treat
    everything as if it were a nail.”

   - *Abraham Maslow*
   #+END_QUOTE
   -----
   
   or /cognition inertia/ in writing book about programming. First
   books about programming were written in a plain English and it was
   ample at that time: there wasn't any programming languages, the
   large set of hexadecimal commands only. Later, when full-fledged
   programming languages was introduced, authors predictably included
   wee chunks of programs into the text of books about programming by
   these languages. It's right. It is much more illustrative and
   comprehensible for readers.

   When later /unit testing/ was introduced it deemed as a special
   concept in software development. What if I ask you: “What should be
   the next step further in that direction?”

   It should be the /programs as the textbook/, written in particular
   programming language, with plentiful number of tests to examplify
   concepts, ideas, approaches hidden behind the wall of mutual
   understanding between a man and machine.

   #+CAPTION: Brain fog
   #+ATTR_HTML: :class rounded float-center :alt True thinking is a tough task
   #+ATTR_HTML: :title The large set of cognitive biases
   http://0--key.github.io/assets/img/pydes/cognitive_bias.jpeg



** Reading as a tourture 

   Avoidance of source code reading (escapism);
   Actually it is a downright grueling task to do


* A harsh deduction

  #+CAPTION: Test failure
  #+ATTR_HTML: :class rounded float-left :alt Animals also test
  #+ATTR_HTML: :title Unconscious testing
  http://0--key.github.io/assets/img/pydes/monkey.jpeg

  Summarize the handful of penetraiting observations above it might be
  dedused:

  The paramount goals of writing are absolute clarity and density, so
  it might sound a quite strange. In reality, it is much complex task
  than it seems and a plethora of already written manuals about
  programming is a strict evidence to interpret this as a _spoiled
  approach_. In contrary: “Why men avoid reading and study some common
  things as programming in just one book? Is it /really/ so boring?”

  My grandma told me “Eugene Onegin” in just three evenings. She knew
  each string in the poem's sequence(!) It was so astounding and 40
  years later I still remember it. Not the poem itself! The
  remembrance of no-limit boundaries for human mind. Now I'm can
  conclude that only natural language is enough complex and
  complicated to transmit such long message for a such long time.

  30 years ago, in 1991 I became a programmer. My tool was a quite
  advanced micro-calculator programmed manually in a
  pseudo-hexadecimal directives. It was incredibly precise, fast as a
  blizzard and it definitely were games there! “The fly of a
  bumblebee” named one.

  Further where were many programming languages studied by the manual
  testing, and in 2016 I push my head in to the wall. After sufficient
  time any piece of my programs became unreadable and seem so knotty
  like some aliens do it by his left toe. The same observation is True
  for programs written not by me. What the crap is going on!

  “Why we spawn such degenerative programs?”: I asked myself and seeking
  for clue 4 years in deep contemplation.

  And now I definitely know why it is so ugly with writing programs
  now. Not a secret at all. The clue to this puzzle is the nature of
  humans, a large set of caveats in their cognitive thinking:

  - =Do anything and anytime like others do=

    If all you know about did something successfully, all what you
    need to do is to mimic them. In other words it is ~heard style~.

  - =If it is so old - it is True by the age=

    A misconseption from our young childhood. Based on ~All adults are
    genious because they're old.~

  - =You can't change it as you like=

    Naturally if a man following his prejudices a long time anough to
    do nothing at all in the shame to do something wrong. ~Yes, he just
    can't do it. Period.~
  

  Unconsciously people do things in a some particular way
  and it seems a queer mistake. It is not common to find your reactive
  behavior as your own error looking backward.

  Why you can't ask yourself: “Why it is so difficult to read any book
  about programming?” Easy and habitual way to take it as granted. But
  for me it is a usual challenge. Maybe I am personally excessively
  curious and persistent to digging up to core of matter. And I have
  to say something about programming.

  Programming is easy by its nature and overcomplicated by the men. It is
  just something wrong with approach to study it.

  As you might notice casual programming handbook often dismantle
  programming wrong.

  Absolutely wrong. It uses English as a stem language, and

  programming language itself dissected by large set of
  _pseudo-tests_ -

  Even if any book can't be pretentious, this one doesn't. It is
  exactly the essence out of learning how to program machines to
  execute yours and only yours orders in a most effective way of
  studying: by sequentially, from the elementary ones to most complex,
  testing its features.
	  

** Several acid notations


** Defining predicatives intentionally

 It's naturally to draw the boundaries around your invention. It's
 neither a silver bullet nor panacea for learners. Cognition demands a
 lot of time for reading and digesting each chapter. Nothing
 misterious.


*** Why Python

*** Why pure Python

*** Already existing solutions overview


** Thurther deduction

   - Conversion a boring manual into a fiction book;
   - Black (Pandorra) Box approach;
   - Programming languages genealogy:
     + Atavisms:
       + 72 char per string;
   - Codex as a phenomena disclosure;
   - Related material allocation on two pages at once;
   - Pomodoro technique realization;


* Testing as a nodal ology tool

  #+CAPTION: An infant conducting test
  #+ATTR_HTML: :alt An infant :title Infant building a tower
  [[http://0--key.github.io/assets/img/pydes/infant-building-a-tower.jpeg]]

  If you're observed an infant behavior strictly enough you might
  notice that it is /a silent (they can't talk yet) testing how things
  work/. A baby with brisk ingenuity implements the series of
  conscious acts and it should be interpreted as a sequence of
  experiments to examine the nature of events. Bear in mind its inborn
  origin, because every child do it absolutely autonomous, we got
  conclusion about a genuine and inborn human inclination on testing
  approach for study anything.


* Several useful tips and tricks                                   :noexport:

** Two pages on the screen

** Git and clone it

** Contribute



* Testing Python primary constants

  Now it is time to concoct our first primitive set of tests to
  determine the existence of /Python primals/ =True=, =False= and
  =None=. It is intentionally simplified to show you the threshold of
  primitivity in valid /Python/ code.

  #+BEGIN_SRC python :tangle tests/test_00_primal_testing_oversimplified.py
    import unittest


    class TestLanguagePrimals(unittest.TestCase):

        def test_does_true_ever_exist(self):
            self.assertTrue(True)

        def test_does_false_ever_exist(self):
            self.assertFalse(False)

        def test_does_none_ever_exist(self):
            self.assertIsNone(None)
  #+END_SRC

  Yes, that's it! Try to launch this code snippet to be ensured that it
  works as expected:

  #+BEGIN_SRC sh
    cd tests
    python3 -m unittest test_00_primal_testing_oversimplified.py
  #+END_SRC

  #+RESULTS:


  Now lets embellish our dry code with /inline comments/:

  #+BEGIN_SRC python :tangle tests/test_01_primal_testing_with_inline_comments.py
    import unittest  # <-- import header


    class TestLanguagePrimals(unittest.TestCase):  # <-- class definition

        def test_does_true_ever_exist(self):  # <-- an atomic test case itself
            # and the sample of in-line comment
            # self-explanatory name of the test case to focus attention
            self.assertTrue(True)  # <-- straight assertion
            # If this test passed successfully than True is really exists

        def test_does_false_ever_exist(self):  # another test case
            self.assertFalse(False)  # False also exists

        def test_does_none_ever_exist(self):  # the last primitive test case
            self.assertIsNone(None)  # None also predefined by the language
  #+END_SRC

  *Tip* It is convenient to compare these two files when you open them
  in two panels simultaneously on the screen:

  #+CAPTION: Two-panel editor view
  #+ATTR_HTML: :alt Two-panel view :title Compare these two files
  [[http://0--key.github.io/assets/img/pydes/compare.png]]

  *You've got to catch the essence of the lesson* 

  Now you're checked up an existence of three _primary Python
  constants_ using =unittest= module and its three methods:

  - =assertTrue=
  - =assertFalse=
  - =assertIsNone=

  It is a simple, minuscule and plain step onto the right path opting
  knowledge in its natural order.


* Switching on lucid Python

  Now you're ready and steady to read, compare and comprehend *Python*
  programs. Yes, there are only two of them, they are /intentionally/
  simplified, but suddenly you're got a /seismic shift/ in your mind.
  From now and forever lets compose our programs in a self-explanatory
  manner, and *Python* would alleviate the pain in mulling around how
  the program works.

  You might notice that we used the set of /inline comments/ to
  describe some significant niceties. Yes, they are not obligatory
  though. To accomplish the switch on pure *Python* we should utilize
  a /multi-line comment/ feature for the much broad depictions. Yes,
  they are not an obligation too, but in many cases they are
  indispensable as a source of clarity for author during writing the
  program and later for all its readers.

  Naturally what such cool feature was already established by *Python*
  and well-known as a [[https://www.python.org/dev/peps/pep-0257/][docstrings]], the special sort of comments.
  Multi-line docstrings consist of a /summary line/, followed by a
  blank line, followed by a /more elaborate description/.

  #+BEGIN_QUOTE
  "A universal convention supplies all of maintainability, clarity,
  consistency, and a foundation for good programming habits too. What
  it doesn't do is insist that you follow it against your will. That's
  Python!"

  - *Tim Peters*
  #+END_QUOTE

  #+BEGIN_SRC python :tangle tests/test_02_primal_testing_full_fledged.py
    #!/usr/bin/python
    # -*- coding: utf-8 -*-
    """A module-level docstring brief single-line description

    A module-level docstring multi-line description. Notice the second line
    with a straight encoding definition. 

    Docstrings do appear in the bytecode, so you can access this through
    the ``__doc__`` attribute. This is also what you'll see if you call
    help() on a module or any other Python object.

    """

    import unittest  # <-- import header

    """The place below an import section reserved for multi-line comments
    which might be utilized as preamble to your Python program. It is
    being red only by humans, not compiled ever, and permits author to
    write down all stuff necessary to be at the foremost place.

    It might be unnecessary in our case, when we write a simplified
    version of programs. But our aim is a paragon of clarity thus it
    should contain all lucidity's attributes.

    You might notice that /coding definition/ on the first string, the
    second string begins with tripled double quotes and a sentence there.
    They are the obligatory attributes if you have intention to do things
    as it should do.

    By its purpose all programming languages should allow readers to
    perceive what exactly this particular text do in a much explicit
    manner. The real state of things, when programs are habitually
    clogged, requires from a literate reader tons of time and perceverance
    for litter decluttering and a core idea grasp. Noticeable that
    nowadays most programs demand from its reader such literacy that it
    made them actually indecipherable for humans and in most cases
    extremely knotty even to its author.

    Nevertheless, this fact usually omitted by specialists, who spent a
    huge amount of time reading so overcomplicated texts of programs.
    Through time, it became a normal if anybody can't make an idea out
    from program's text on the fly.

    “It is just lack of experience!”: they say usually. You might object
    by notation that several professionals can't catch the essence out
    from that text because it is poorly written, they answer something
    like: “It works well enough to be scrutinized much diligently.”

    """


    class TestLanguagePrimals(unittest.TestCase):  # <-- class definition
        """The class-level for brief single-line docstring

        Class defininition begins this reserved word /class/ following by
        the /name of class/ and its /parent class/ in the brackets. On
        first steps it might be like a magic mantra to enter the /test
        suite/

        """

        def test_does_true_ever_exist(self):  # <-- an atomic test case itself
            """A single-line brief description for particular test case"""
            self.assertTrue(True)  # <-- straight assertion
            # If this test passed successfully than True is really exists

        def test_does_false_ever_exist(self):  # another test case
            """A single-line brief description for particular test case"""
            self.assertFalse(False)  # False also exists

        def test_does_none_ever_exist(self):  # the last primitive test case
            """A single-line brief description for particular test case"""
            self.assertIsNone(None)  # None also predefined by the language


    """This is a conclusion multi-line comment section. It is useful to
    put all bottom-line conclusion there."""
  #+END_SRC


* The set of attributes required                                   :noexport:


** The top
   #+NAME: module-level-docstring
   #+BEGIN_SRC python :session test
     # -*- coding: utf-8 -*-
     """A module-level docstring

     Notice the comment above the docstring specifying the encoding.
     Docstrings do appear in the bytecode, so you can access this through
     the ``__doc__`` attribute. This is also what you'll see if you call
     help() on a module or any other Python object.

     It might be unnecessary in our case, when we write a simplified
     version of programs. If the aim is a paragon of clarity it should
     contain all required attributes of clarity and further support.

     You might notice that /coding definition/ on the first string, the
     second string begins with tripled double quotes and a sentence there.
     They are the obligatory attributes if you have intention to do things
     as it should do.

     """
    #+END_SRC


** The import

    #+NAME: import-header
    #+BEGIN_SRC python :session test
      import unittest

      """By its purpose all programming languages should allow the reader to
      understand what exactly this particular text do in a much explicit
      manner. The real state of things requires a literate reader with a huge
      experience exactly in reading programs and comprehension. Noticeable
      that nowadays most programs demand from reader such proficiency that
      it made them truly readable for the handful of true geeks only.

      Nevertheless, this fact usually omitted by specialists, who spent a
      huge amount of time reading so overcomplicated texts of programs.
      Through time, it became a normal if anybody can't grasp an idea out
      from program's source code on the fly.

      “It is just lack of experience!”: they say usually. You might object
      by notation that several professionals can't catch the essence out
      from that text because it poorly written, they answer something like:
      “It works well enough to be scrutinized much more precisely.”

      Nowadays it is deemed as normal to lack capability to understand
      source code even for professionals. Naturally it is abnormal.

      """
    #+END_SRC

    #+RESULTS: import-header


** None-False-True existence assertion


    #+NAME: none-false-true-assertion
    #+BEGIN_SRC python :session test
      class TestLanguageBase(unittest.TestCase):  # <-- class definition
          """begins this reserved word /class/ following by the /name of class/
          and its /parent class/ in the brackets. On first steps it might be
          like a magic mantra to enter the /test suite/.

          The first and foremost taks for testing is to ensure how testing
          tools work. In our case lets begit from the simplest things ever -
          lets discover built-in constants True, False, None with already
          defining testing methods one by one.

          | Method                    | Checks that          |
          |---------------------------+----------------------+
          | assertEqual(a, b)         | a == b               |
          | assertNotEqual(a, b)      | a != b               |
          | assertTrue(x)             | bool(x) is True      |
          | assertFalse(x)            | bool(x) is False     |
          | assertIs(a, b)            | a is b               |
          | assertIsNot(a, b)         | a is not b           |
          | assertIsNone(x)           | x is None            |
          | assertIsNotNone(x)        | x is not None        |
          | assertIn(a, b)            | a in b               |
          | assertNotIn(a, b)         | a not in b           |
          | assertIsInstance(a, b)    | isinstance(a, b)     |
          | assertNotIsInstance(a, b) | not isinstance(a, b) |

          """

          def test_does_true_ever_exist(self):  # <-- an atomic test case itself
              # and the sample of in-line comment
              # self-explanatory name of the test case to focus attention
              self.assertTrue(True)  # <-- straight assertion
              # True really exists.
              # if this test do pass with success.

          def test_does_false_ever_exist(self):  # No comments
              self.assertFalse(False)  # False also exists

          def test_does_none_ever_exist(self):  # no comments
              self.assertIsNone(None)  # None also predefined by the language

          """ Now it became obious that three built-in constants are well-defined
          out of the box.  It is very time to compare them against each other.
          """

          def test_none_fasle_true_comparison(self):
              self.assertIsNotNone(True)  # Naturally, neiver False
              self.assertIsNotNone(False)  # nor True are not None
              self.assertFalse(None)  # !! None has a Boolean False
              #
              self.assertIs(True, True)  #
              self.assertIs(False, False)  #
              self.assertIs(None, None)  #
              #
              self.assertNotEqual(False, True)  #
              self.assertNotEqual(True, None)  #
              self.assertNotEqual(False, None)  #
              #
              self.assertIsNotNone(False)  #
              self.assertIsNotNone(True)  #


      """
      | Method                    | Checks that          |
      |---------------------------+----------------------+
      | assertEqual(a, b)         | a == b               |
      | assertNotEqual(a, b)      | a != b               |
      | assertTrue(x)             | bool(x) is True      |
      | assertFalse(x)            | bool(x) is False     |
      | assertIs(a, b)            | a is b               |
      | assertIsNot(a, b)         | a is not b           |
      | assertIsNone(x)           | x is None            |
      | assertIsNotNone(x)        | x is not None        |
      | assertIn(a, b)            | a in b               |
      | assertNotIn(a, b)         | a not in b           |
      | assertIsInstance(a, b)    | isinstance(a, b)     |
      | assertNotIsInstance(a, b) | not isinstance(a, b) |

      Now we definitely check up several methods of assertion embedded into
      Python unittest module, and ensure that three fundamental constants
      are also accessible out from the box.

      The four methods at the bottom of the table:

       - assertIn(a, b)
       - assertNotIn(a, b)
       - assertIsInstance(a, b)
       - assertNotIsInstance(a, b)

      are unnecessary right now because their purpose is testing of
      sequencies and instances wich will be introduced a bit later.

      In the next chapter new and principal concepts will be introduced.

      """
    #+END_SRC

    #+RESULTS: true-assertion


* Code elaboration

  #+NAME: full-fledged-sample
  #+BEGIN_SRC python :noweb yes :session one
    # -*- coding: utf-8 -*-
    """Now it is the moment to distill your knowledge about writing
    =unittests= in ~Python~. Our previous work in
    =tests/test_00dumb_testing.py= spare too much place in case if you're
    grasp the core idea. Exactly:

       - Module comments;
       - Import section;
       - Test class definition;
       - Set of test cases

    are necesseties to be clear when you're in writing ~Python~ code. Lets
    create a much dense test suite out from existing one and put it in a
    new file =tests/test_01false_true_none_existence.py=

    """

    import unittest

    """The initial Python test suite

    Asserts the existence True, False and None in Python
    """


    class TestFundamentalConstantsExistence(unittest.TestCase):

        """Put all the existence tests together"""

        def test_the_existence(self):
            self.assertTrue(True)  # <-- straight assertion
            self.assertFalse(False)  # False also exists
            self.assertIsNone(None)  # None also predefined by the language


    """Naturally that it is more convenient to tame a dense and terse code
    blocks which are well-fitted on a single page. Thus, try to split all
    your tests into /logical/ blocks for clarity purpose."""
  #+END_SRC

  #+NAME: full-fledged-sample-comparison
  #+BEGIN_SRC python :noweb yes :session second
    # -*- coding: utf-8 -*-
    """Only code to compare None, True and False"""

    import unittest


    class TestCompareFundamentals(unittest.TestCase):

        def test_none_fasle_true_comparison(self):
            self.assertIsNotNone(True)  # Naturally, neiver False
            self.assertIsNotNone(False)  # nor True are not None
            self.assertFalse(None)  # !! None has a Boolean False
            #
            self.assertIs(True, True)  #
            self.assertIs(False, False)  #
            self.assertIs(None, None)  #
            #
            self.assertNotEqual(False, True)  #
            self.assertNotEqual(True, None)  #
            self.assertNotEqual(False, None)  #
            #
            self.assertIsNotNone(False)  #
            self.assertIsNotNone(True)  #


    """Seems it is much elegant than before, but less self-explanatory"""
  #+END_SRC
   
** Further exploration

** Zero, One and a Symbol


*** Assertion and assignment
*** True, False, None, == and = comparison, != and Not

*** Boolean operations

*** Arithmetics


*** None-False-True comparison


     #+NAME: none-false-true-comparison-assertion
     #+BEGIN_SRC python :session test
       class TestCompareFundamentals(unittest.TestCase):

           """Now, when we ensure in existence of None, False and Ture constants,
           it is very time to compare them with its own derivatives as zero
           (0), one (1), the letter('A')

           """

           def test_does_zero_really_boolean_false(self):
               self.assertFalse(0)  #
     #+END_SRC

     #+RESULTS: false-assertion



* Innate datatypes testing


* Enter the Function


* Enter the Object
