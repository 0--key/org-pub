#+BEGIN_EXPORT html
---
layout: post
title: Dissecting Python
tagline: " inside out"
permalink: /python/books/disecting_python.html
categories: [Python Dissection]
tags: [book, template]
---
#+END_EXPORT

#+STARTUP: showall
#+OPTIONS: tags:nil num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t
#+TOC: headlines 2
#+PROPERTY:header-args :results output :exports both :eval no-export

* Gestation                                                        :noexport:

** Primary material gathering;

*** Books

    - "Learning Python" & "Python Pocket Reference" by Mark Lutz
    - 

*** DONE Quotes

    - "Programs must be written for people to read, and only incidentally  
     for machines to execute."

     Abelson & Sussman, SICP, preface to the first edition

    - "Short words are best and the old words when short are best of all."

      Winston Churchill

    - “The glass is neither half empty nor half full. It’s simply
      larger than it needs to be.”

      Grace Hopper

    - “Manage things. Lead people.”

      Grace Hopper

*** Snippets

*** Thoughts

    Why computer programming is a such tough task for humans? There
    are several plain predicatives to deem that is just overthinked.

**** 5 basic concepts of any programming language:

     - Variables;
     - Data structures;
     - Control structures;
     - Syntax;
     - Tools;


     
**** Major paradigms of programming:

     - Imperative;
     - Logical;
     - Functional;
     - Object-oriented;

       

     So, at the first glance all these concepts seem clear, dense and
     terse.

     



    
** Indexing as an ordered sequence;

** Wrapping and extension.


* Harsh overture

  The paramount goal of writing is absolute clarity and density, so it
  might sound a quite strange. In reality it is much complex task than
  it seems and a plethora of already written manuals about programming
  is a strict evidence to interpret this as a _spoiled approach_.
  Unconciously people do things in a some particular way and it seems
  a queer mistake. Seldom it is convenient to look backward and find
  your reactive behaviour as your own error.

  Why you can't ask yourself: "Why it is so difficult to read any book
  about programming?" Easy and habitual way to take it as granted. But
  for me it is a usual challenge. May be I am personally excessively
  curious and persistent to digging up to core of matter. And I have
  to say something about programming.

  Programming is easy by its nature and overcomplicated by the men. It is
  just something wrong with approach to study it. As you might notice
  casual programming handbook often dismantle programming wrong.
  Absolutely wrong. It uses English as a stem language, and
  programming language itself dissected by large set of
  _pseudo-tests_ -

  Even if any book can't be pretentious, this one doesn't. It is
  exactly the essense out of learning how to program machines to
  execute yours and only yours orders in a most effective way of
  studying: by sequentially, from the elementary ones to most complex,
  testing its features.
	  

* Relevant quotes
    #+BEGIN_QUOTE
    Programs must be written for people to read, and only incidentally
      for machines to execute."
   #+HTML: <p align="right">
   - Abelson & Sussman, SICP, preface to the first edition
   #+HTML: </p>   
   #+END_QUOTE

   -----
   #+BEGIN_QUOTE
    "Short words are best and the old words when short are best of
      all."
   #+HTML: <p align="right">
   - Winston Churchill
   #+HTML: </p>   
   #+END_QUOTE

   -----

    #+BEGIN_QUOTE
    “The glass is neither half empty nor half full. It’s simply larger
      than it needs to be.”
   #+HTML: <p align="right">
   - Grace Hopper
   #+HTML: </p>   
   #+END_QUOTE

   -----

   #+BEGIN_QUOTE
    “Manage things. Lead people.”
   #+HTML: <p align="right">
   - Grace Hopper
   #+HTML: </p>   
   #+END_QUOTE

   -----


* General observations:
     

** Debugging is a major task


   for a typical programmer and often it consumes up to 90% of their
   efforts to develop and maintain software nowadays;


** Cognitive dissonance and size of manuals

   There are tons of material and most of it represents ~programming
   language~ in an imperative style.


** An average age of readers

   
** Testing as an innate tool to learn for humans;
   - Testing in CS is a comparatively young concept;


** Einstellung effect in writing book about programming;


** Reading as a tourture 

   Avoidance of source code reading (escapism);


* Several acid notations


* Defining predicatives intentionally

It's naturally to draw the boundaries around your invention. It's
neither a silver bullet nor panacea for learners. Cognition demands a
lot of time for reading and digesting each chapter. Nothing
misterious.


** Why Python

** Why pure Python

** Already existing solutions overview


* Thurther deduction

  - Conversion a boring manual into a fiction book;
  - Black (Pandorra) Box approach;
  - Programming languages genealogy:
    + Atavisms:
      + 72 char per string;
  - Codex as a phenomena disclosure;
  - Related material allocation on two pages at once;
  - Pomodoro technique realization;


* Testing as a nodal ology tool


** A dumb testing set (test the test itself)


** Testing Python innate constants

*** Boolean operations

*** Arithmetics


* Innate datatypes testing


* Enter the Function


* Enter the Object
