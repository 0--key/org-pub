#+BEGIN_EXPORT html
---
layout: post
title: Dissecting Python
tagline: " inside out"
permalink: /python/books/disecting_python.html
categories: [Python Dissection]
tags: [book, template]
---
#+END_EXPORT

#+STARTUP: showall
#+OPTIONS: tags:nil num:nil \n:nil @:t ::t |:t ^:{} _:{} *:t
#+TOC: headlines 2
#+PROPERTY:header-args :results output :exports both :eval no-export

* Gestation                                                        :noexport:

** TODO Primary material gathering;

*** TODO Snippets
    - Docs about testing;
    - Docs about working with source code in Babel;

*** TODO Thoughts

**** Thesis and antithesis
     Thesis – a statement or theory that is put forward as a premise
     to be maintained or. proved. Antithesis – the negation or
     contradiction of the thesis. Synthesis – the resolution of the
     conflict between thesis and antithesis.
**** Retrospecive analysis

     - Coding in a modern sense of it was born in 40s. It was
       something in the middle of lore and mistery;
     - The idea of /compiler/ as a middleware between humans and
       machines was on the tip of the tongue but implemented by Grace
       Hopper titanic efforts and phenomenal persistence only a decade
       later;
     - The bedrock for /high-level/ programming languages;
     - Unit-testing as a /separate approach/ in programming was
       introduced in 90s;

**** Cognition inertia
**** Appollo 11 computer

     Verb --> noun approach

**** __main__ in their footer

     as a sign of uncompetence - run a =Python= program in your
     terminal doesn't seem a good idea. At all. 

     Why computer programming is a such tough task for humans? There
     are several plain predicatives to deem that is just overthinked.

**** 5 basic concepts of any programming language:

     - Variables;
     - Data structures;
     - Control structures;
     - Syntax;
     - Tools;

**** Major paradigms of programming:

     - Imperative;
     - Logical;
     - Functional;
     - Object-oriented;

       

     So, at the first glance all these concepts seem clear, dense and
     terse.

**** Wrong approach in studying

     Let's make a brisk glance on the history of programming
     languages. In the most cases it would shade the light on
     question: “How does it ever happen?”

     It is not secret that coding and computing by electronic
     macnihens is a relatevely fossil lore for humans. I suppose it
     was 1940s as an early begining. It was a straightforward coding
     due to absence of high-level programming languages.


     In 1950s Grace Hopper achived success and implement on practive
     her idea of compilation human-written programs into
     machine-readable set of precise instructions. The gestation of
     high-level programming languges started since.
     
     The plehora of new and modern human-readable hight-level
     programming languages was announced in 1970s due to widely
     spreaded idea to write programs as a human-friendly text and
     compile it later into the source code (mostly unreadable by
     humans) executable by machines at least.
     
**** Separate folder with tests

     It will serve as an essence of studying material and later, I
     hope, as an yeast for your further usage as a backbone for Python
     development. Just pull my repository and launch the set of tests
     on your local environment.

      As I can imagine it would be something
      ==/0--key/0-py/tests/blackbox/

      - Innate constants (True, False, None)
      - Operators:
	- Assignment
	- Comparison (==, <, >, != etc.)

    
**** Python actual version

     There are two =Python= branches and the youngest one will serve us
     as a subject of our deductive dissection. Dow you heard about
     ~Black Box https://www.guru99.com/black-box-testing.html~ approach
     in study? Yes, it is so old by the nature, and innovative nowadays
     in software testing only. Not in learning practice once again due
     the stunt prejudice about the age of practicioqneer.
    
**** DONE False Footnotes with new words meaning

     Inappropriate veiw and feel.

**** DONE Align img in bootstrap

*** DONE Quotes

    - "Programs must be written for people to read, and only incidentally  
     for machines to execute."

     Abelson & Sussman, SICP, preface to the first edition

    - "Short words are best and the old words when short are best of all."

      Winston Churchill

    - “The glass is neither half empty nor half full. It’s simply
      larger than it needs to be.”

      Grace Hopper

    - “Manage things. Lead people.”

      Grace Hopper

*** Books

    - "Learning Python" & "Python Pocket Reference" by Mark Lutz
    - 

** Indexing as an ordered sequence

*** DONE Dedication

*** TODO Preface

    Main incentives
    Major aim for writing
    Minor target
    Satellite achievements
    Average readers audience

** Wrapping and extension.


* Dedication

  For my tiny family


* Relevant quotes
    #+BEGIN_QUOTE
    Programs must be written for people to read, and only incidentally
    for machines to execute."

   - *Abelson & Sussman, SICP, preface to the first edition*
   #+END_QUOTE

   -----
   #+BEGIN_QUOTE
    "Short words are best and the old words when short are best of
      all."

   - *Winston Churchill*
   #+END_QUOTE

   -----

    #+BEGIN_QUOTE
    “The glass is neither half empty nor half full. It’s simply larger
      than it needs to be.”

   - *Grace Hopper*
   #+END_QUOTE

   -----

   #+BEGIN_QUOTE
    “Manage things. Lead people.”

   - *Grace Hopper*
   #+END_QUOTE

   -----


* Preface

  This book is about programming machines to do precisely what humans
  ordered them. Like a thousand of other books already written about
  the same subject. The core discrepancy is the /style/ of this book:
  it is *not* yet another user manual or user journal generously
  spiced by comments and notes.

  It is a book in a wide sense of this word: it has an objective, the
  subjects and the plot. The principal objective in this book is
  Python and its usage by humans, the subjects are students, teachers,
  books, programmers, software engineers, other professionals related
  to programming. And the plot is a *misleading*, its history, the
  current state of things with focus on programming, obvious
  deductions out there and the straightforward approach to eradicate
  this phenomena once and forever.

  The main intention of this book is to take to the reader chance to
  be fun among reading, to allow them to be pleased in time they're
  reading this book, to alleviate the headache and other pain during
  /studying programming by excluding cramming/ as a redundant and
  unnecessary procedure.

   
* Harsh overture

      #+CAPTION: Test failure
      #+ATTR_HTML: :class rounded float-left :alt Animals also test
      #+ATTR_HTML: :title Unconscious testing
      [[http://0--key.github.io/assets/img/pydes/monkey.jpeg]]

  The paramount goal of writing is absolute clarity and density, so it
  might sound a quite strange. In reality, it is much complex task
  than it seems and a plethora of already written manuals about
  programming is a strict evidence to interpret this as a _spoiled
  approach_. In contrary: “Why men avoid reading and study some common
  things as programming in just one book? Is it /really/ so boring?”

  My grandma told me “Eugene Onegin” in just three evenings. She knew
  each string in the poem's sequence(!) It was so astounding and 40
  years later I still remember it. Not the poem itself! The
  remembrance of no-limit boundaries for human mind. Now I'm can
  conclude that only natural language is enough complex and
  complicated to transmit such long message for a such long time.

  30 years ago, in 1991 I became a programmer. My tool was a quite
  advanced micro-calculator programmed manually in a
  pseudo-hexadecimal directives. It was incredibly precise, fast as a
  blizzard and it definitely were games there! “The fly of a
  bumblebee” named one.

  Further where were many programming languages studied by the manual
  testing, and in 2016 I push my head in to the wall. After sufficient
  time any piece of my programs became unreadable and seem so knotty
  like some aliens do it by his left toe. The same observation is True
  for programs written not by me. What the crap is going on!

  “Why we spawn such degenerative programs?”: I asked myself and seeking
  for clue 4 years in deep contemplation.

  And now I definitely know why it is so ugly with writing programs
  now. Not a secret at all. The clue to this puzzle is the nature of
  humans, a large set of caveats in their cognitive thinking:

  - =Do anything and anytime like others do=

    If all you know about did something successfully, all what you
    need to do is to mimic them. In other words it is ~heard style~.

  - =If it is so old - it is True by the age=

    A misconseption from our young childhood. Based on ~All adults are
    genious because they're old.~

  - =You can't change it as you like=

    Naturally if a man following his prejudices a long time anough to
    do nothing at all in the shame to do something wrong. ~Yes, he just
    can't do it. Period.~
  

  Unconsciously people do things in a some particular way
  and it seems a queer mistake. It is not common to find your reactive
  behavior as your own error looking backward.

  Why you can't ask yourself: “Why it is so difficult to read any book
  about programming?” Easy and habitual way to take it as granted. But
  for me it is a usual challenge. Maybe I am personally excessively
  curious and persistent to digging up to core of matter. And I have
  to say something about programming.

  Programming is easy by its nature and overcomplicated by the men. It is
  just something wrong with approach to study it.

  As you might notice casual programming handbook often dismantle
  programming wrong.

  Absolutely wrong. It uses English as a stem language, and

  programming language itself dissected by large set of
  _pseudo-tests_ -

  Even if any book can't be pretentious, this one doesn't. It is
  exactly the essence out of learning how to program machines to
  execute yours and only yours orders in a most effective way of
  studying: by sequentially, from the elementary ones to most complex,
  testing its features.
	  

* General observations:
     

** Debugging is a major time-consuming task


   for a casual programmer and often it consumes up to 90% of their
   efforts to develop and maintain software nowadays;


** Cognitive dissonance and size of manuals

   There are tons of material and most of it represents ~programming
   language~ in an imperative style.


** An average age of readers

   
** Testing as an innate tool to learn for humans;
   - Testing in CS is a comparatively young concept;


** Einstellung effect in writing book about programming;


** Reading as a tourture 

   Avoidance of source code reading (escapism);


* Several acid notations


* Defining predicatives intentionally

It's naturally to draw the boundaries around your invention. It's
neither a silver bullet nor panacea for learners. Cognition demands a
lot of time for reading and digesting each chapter. Nothing
misterious.


** Why Python

** Why pure Python

** Already existing solutions overview


* Thurther deduction

  - Conversion a boring manual into a fiction book;
  - Black (Pandorra) Box approach;
  - Programming languages genealogy:
    + Atavisms:
      + 72 char per string;
  - Codex as a phenomena disclosure;
  - Related material allocation on two pages at once;
  - Pomodoro technique realization;


* Testing as a nodal ology tool

      #+CAPTION: An infant conducting test
      #+ATTR_HTML: :alt An infant :title Infant building a tower
      [[http://0--key.github.io/assets/img/pydes/infant-building-a-tower.jpeg]]

If you're observed an infant behavior strictly enough you might
notice that it is /a silent (they can't talk yet) testing how things
work/. With brisk ingenuity baby implements the series of conscious acts
and it should be interpreted as experiments to examine the nature of
events. Bear in mind its inborn origin, because every child do it
absolutely autonomous, we got conclusion about a native and natural
compatibility of humans and testing approach for study.


* A dumb testing set (test the test itself)                        :noexport:

   #+BEGIN_SRC python :noweb yes :tangle tests/test_00dumb_testing.py
     <<import-header>>


     <<none-false-true-assertion>>


     <<none-false-true-comparison-assertion>>
   #+END_SRC


* Testing Python innate constants

  The bedrock of testing a programming language.

   #+NAME: import-header
   #+BEGIN_SRC python :session test
     import unittest

     """By its purpose all programming languages should allow the reader to
     understand what exactly this particular text do in a much explicit
     manner. The real state of things requires a literate reader with a huge
     experience exactly in reading programs and comprehension. Noticeable
     that nowadays most programs demand from reader such proficiency that
     it made them truly readable for the handful of true geeks only.

     Nevertheless, this fact usually omitted by specialists, who spent a
     huge amount of time reading so overcomplicated texts of programs.
     Through time, it became a normal if anybody can't grasp an idea out
     from program's source code on the fly.

     “It is just lack of experience!”: they say usually. You might object
     by notation that several professionals can't catch the essence out
     from that text because it poorly written, they answer something like:
     “It works well enough to be scrutinized much more precisely.”

     Nowadays it is deemed as normal to lack capability to understand
     source code even for professionals. Naturally it is abnormal.

     """
   #+END_SRC

   #+RESULTS: import-header

   #+NAME: none-false-true-assertion
   #+BEGIN_SRC python :session test
     class TestLanguageBasemet(unittest.TestCase):

         """The first and foremost taks for testing is to ensure how testing
         tools work. In our case lets begit from the simplest things ever -
         lets discover built-in constants True, False, None with already
         defining testing methods one by one.

         | Method                    | Checks that          |
         |---------------------------+----------------------+
         | assertEqual(a, b)         | a == b               |
         | assertNotEqual(a, b)      | a != b               |
         | assertTrue(x)             | bool(x) is True      |
         | assertFalse(x)            | bool(x) is False     |
         | assertIs(a, b)            | a is b               |
         | assertIsNot(a, b)         | a is not b           |
         | assertIsNone(x)           | x is None            |
         | assertIsNotNone(x)        | x is not None        |
         | assertIn(a, b)            | a in b               |
         | assertNotIn(a, b)         | a not in b           |
         | assertIsInstance(a, b)    | isinstance(a, b)     |
         | assertNotIsInstance(a, b) | not isinstance(a, b) |

         """

         def test_does_true_ever_exist(self):  # <-- an atomic test case itself
             # and the sample of in-line comment
             # self-explanatory name of the test case to focus attention
             self.assertTrue(True)  # <-- straight assertion
             # True really exists.
             # if this test do pass with success.

         def test_does_false_ever_exist(self):  # No comments
             self.assertFalse(False)  # False also exists

         def test_does_none_ever_exist(self):  # no comments
             self.assertIsNone(None)  # None also predefined by the language

         """ Now it became obious that three built-in constants are well-defined
         out of the box.  It is very time to compare them against each other.
         """

         def test_none_fasle_true_comparison(self):
             self.assertIsNotNone(True)  # Naturally, neiver False
             self.assertIsNotNone(False)  # nor True are not None
             self.assertFalse(None)  # !! None has a Boolean False
   #+END_SRC

   #+RESULTS: true-assertion

   #+NAME: none-false-true-comparison-assertion
   #+BEGIN_SRC python :session test
     class TestCompareFundamentals(unittest.TestCase):

         """Now, when we ensure in existence of None, False and Ture constants,
         it is very time to compare them with its own derivatives as zero
         (0), one (1), the letter('A')

         """

         def test_does_zero_really_boolean_false(self):
             self.assertFalse(0)  #
   #+END_SRC

   #+RESULTS: false-assertion


*** Assertion and assignment
*** True, False, None, == and = comparison, != and Not

*** Boolean operations

*** Arithmetics


* Innate datatypes testing


* Enter the Function


* Enter the Object
